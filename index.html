
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ¦ íŒ¨í„´ì—ì„œ í¬ë¦¬ìŠ¤íƒˆë¡œ - ê°œë³„ ìœ ê¸°ì  SVG ëª¨í•‘</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: url('b_bg.png') center/cover no-repeat;
            font-family: 'JetBrains Mono', 'Courier New', monospace;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            
        }
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap');
    </style>
    
</head>
<body>

    <script>
        // PNG ì´ë¯¸ì§€ ë³€ìˆ˜ë“¤ (ê¸°ì¡´ ì½”ë“œ ë§¨ ìœ„ì— ì¶”ê°€)
        let pngImages = [];
        let crystals = [];
        let activeCrystal = -1;
        let crystalProgress = [0, 0, 0];
        let canvasWidth, canvasHeight;
        
        // í…ìŠ¤íŠ¸ í•´ì²´ ë³€ìˆ˜
let scrollDisintegration = 0;

        // íŒŒí‹°í´ ì‹œìŠ¤í…œ ë³€ìˆ˜ë“¤
        let particles = [];
        let mouseParticles = [];
        let shockwaves = [];
        let lastMouseX = 0;
        let lastMouseY = 0;
        let scrollVelocity = 0;
        let lastScrollY = 0;
        
        // íŒŒí‹°í´ í´ë˜ìŠ¤
        class Particle {
            constructor(x, y, type = 'ice') {
                this.x = x;
                this.y = y;
                this.vx = random(-1, 1);
                this.vy = random(0.5, 2);
                this.size = random(2, 6);
                this.angle = random(TWO_PI);
                this.angleVel = random(-0.1, 0.1);
                this.life = 1.0;
                this.maxLife = random(60, 120);
                this.type = type;
                this.color = this.getColorForPosition();
                this.gravity = 0.05;
                this.airResistance = 0.99;
            }
            
            getColorForPosition() {
                // ë§ˆìš°ìŠ¤ ìœ„ì¹˜ì— ë”°ë¼ ê°€ì¥ ê°€ê¹Œìš´ í¬ë¦¬ìŠ¤íƒˆì˜ ìƒ‰ìƒ ë°˜ì˜
                let closestDist = Infinity;
                let closestCrystal = null;
                
                for (let crystal of crystals) {
                    let d = dist(this.x, this.y, crystal.x, crystal.y);
                    if (d < closestDist) {
                        closestDist = d;
                        closestCrystal = crystal;
                    }
                }
                
                if (closestCrystal && closestDist < 200) {
                    let influence = map(closestDist, 0, 200, 1, 0);
                    return {
                        r: lerp(255, closestCrystal.color[0], influence),
                        g: lerp(255, closestCrystal.color[1], influence),
                        b: lerp(255, closestCrystal.color[2], influence)
                    };
                }
                
                return { r: 255, g: 255, b: 255 };
            }
            
            update() {
                // ë¬¼ë¦¬ ì‹œë®¬ë ˆì´ì…˜
                this.vy += this.gravity;
                this.vx *= this.airResistance;
                this.vy *= this.airResistance;
                
                // ìŠ¤í¬ë¡¤ ì˜í–¥
                this.vy += scrollVelocity * 0.1;
                
                this.x += this.vx;
                this.y += this.vy;
                this.angle += this.angleVel;
                
                this.life -= 1 / this.maxLife;
                
                // ì¶©ê²©íŒŒ ì˜í–¥
                for (let shock of shockwaves) {
                    let d = dist(this.x, this.y, shock.x, shock.y);
                    if (d < shock.radius && d > shock.radius - 30) {
                        let force = (1 - shock.life) * 10;
                        let angle = atan2(this.y - shock.y, this.x - shock.x);
                        this.vx += cos(angle) * force;
                        this.vy += sin(angle) * force;
                    }
                }
            }
            
            display() {
                push();
                translate(this.x, this.y);
                rotate(this.angle);
                
                let alpha = this.life * 255;
                fill(this.color.r, this.color.g, this.color.b, alpha * 0.8);
                noStroke();
                
                // ë‹¤ì´ì•„ëª¬ë“œ ëª¨ì–‘ì˜ ì–¼ìŒ ì¡°ê°
                beginShape();
                vertex(0, -this.size);
                vertex(this.size * 0.6, 0);
                vertex(0, this.size);
                vertex(-this.size * 0.6, 0);
                endShape(CLOSE);
                
                // ë°˜ì§ì„ íš¨ê³¼
                if (random() < 0.3) {
                    fill(255, 255, 255, alpha * 0.4);
                    ellipse(0, 0, this.size * 0.5, this.size * 0.5);
                }
                
                pop();
            }
            
            isDead() {
                return this.life <= 0 || this.y > canvasHeight + 50;
            }
        }
        
        // ë§ˆìš°ìŠ¤ ë”°ë¼ë‹¤ë‹ˆëŠ” íŒŒí‹°í´ í´ë˜ìŠ¤
        class MouseParticle extends Particle {
            constructor(x, y) {
                super(x, y, 'mouse');
                this.targetX = x;
                this.targetY = y;
                this.vx = random(-2, 2);
                this.vy = random(-2, 2);
                this.size = random(1, 4);
                this.trail = [];
                this.maxTrailLength = 5;
            }
            
            update() {
                // ë§ˆìš°ìŠ¤ ë”°ë¼ê°€ê¸°
                let dx = mouseX - this.x;
                let dy = mouseY - this.y;
                let dist = sqrt(dx * dx + dy * dy);
                
                if (dist > 5) {
                    this.vx += dx * 0.02;
                    this.vy += dy * 0.02;
                }
                
                // ì†ë„ ì œí•œ
                let speed = sqrt(this.vx * this.vx + this.vy * this.vy);
                if (speed > 5) {
                    this.vx = (this.vx / speed) * 5;
                    this.vy = (this.vy / speed) * 5;
                }
                
                this.vx *= 0.95;
                this.vy *= 0.95;
                
                // íŠ¸ë ˆì¼ ì—…ë°ì´íŠ¸
                this.trail.push({ x: this.x, y: this.y });
                if (this.trail.length > this.maxTrailLength) {
                    this.trail.shift();
                }
                
                this.x += this.vx;
                this.y += this.vy;
                this.angle += this.angleVel;
                
                this.life -= 1 / this.maxLife;
                this.color = this.getColorForPosition();
            }
            
            display() {
                // íŠ¸ë ˆì¼ ê·¸ë¦¬ê¸°
                for (let i = 0; i < this.trail.length; i++) {
                    let t = this.trail[i];
                    let alpha = map(i, 0, this.trail.length, 0, this.life * 100);
                    fill(this.color.r, this.color.g, this.color.b, alpha);
                    noStroke();
                    let trailSize = map(i, 0, this.trail.length, this.size * 0.3, this.size);
                    ellipse(t.x, t.y, trailSize, trailSize);
                }
                
                // ë©”ì¸ íŒŒí‹°í´
                super.display();
            }
        }
        
        // ì¶©ê²©íŒŒ í´ë˜ìŠ¤
        class Shockwave {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 0;
                this.maxRadius = 300;
                this.life = 1.0;
                this.speed = 8;
            }
            
            update() {
                this.radius += this.speed;
                this.life = 1 - (this.radius / this.maxRadius);
                this.speed *= 0.98;
            }
            
            display() {
                push();
                noFill();
                strokeWeight(3);
                stroke(255, 255, 255, this.life * 100);
                ellipse(this.x, this.y, this.radius * 2, this.radius * 2);
                
                strokeWeight(1);
                stroke(255, 255, 255, this.life * 50);
                ellipse(this.x, this.y, (this.radius - 10) * 2, (this.radius - 10) * 2);
                pop();
            }
            
            isDead() {
                return this.life <= 0;
            }
        }
        
        function setup() {

            
            // A3 ë¹„ìœ¨ (1.414:1) ìœ ì§€í•˜ë©´ì„œ í™”ë©´ì— ë§ì¶¤
            let windowRatio = windowWidth / windowHeight;
            let a3Ratio = 1.414;
            
            if (windowRatio > a3Ratio) {
                canvasHeight = windowHeight;
                canvasWidth = canvasHeight * a3Ratio;
            } else {
                canvasWidth = windowWidth;
                canvasHeight = canvasWidth / a3Ratio;
            }
            
            createCanvas(canvasWidth, canvasHeight);
            
            let spacing = canvasWidth / 3;
            let graphicScale = Math.min(canvasWidth / 1200, canvasHeight / 600) * 3.5;
            
            crystals = [
                { 
                    x: spacing * 0.5, y: canvasHeight * 0.5, type: 0, 
                    svgCenterX: 254.93, svgCenterY: 441.76, svgRadius: 197.9,
                    color: [115, 187, 255], scale: graphicScale
                },
                { 
                    x: spacing * 1.5, y: canvasHeight * 0.5, type: 1, 
                    svgCenterX: 606.42, svgCenterY: 451.8, svgRadius: 192.54,
                    color: [103, 172, 255], scale: graphicScale
                },
                { 
                    x: spacing * 2.5, y: canvasHeight * 0.5, type: 2, 
                    svgCenterX: 955.37, svgCenterY: 451.61, svgRadius: 176.28,
                    color: [59, 158, 255], scale: graphicScale * 1.3
                }
            ];

            pngImages[0] = loadImage('icy1.png'); // ì²« ë²ˆì§¸ í¬ë¦¬ìŠ¤íƒˆìš©
    pngImages[1] = loadImage('icy2.png'); // ë‘ ë²ˆì§¸ í¬ë¦¬ìŠ¤íƒˆìš©  
    pngImages[2] = loadImage('icy3.png'); // ì„¸ ë²ˆì§¸ í¬ë¦¬ìŠ¤íƒˆìš©
            
            console.log('ğŸ¦ íŒ¨í„´ì—ì„œ í¬ë¦¬ìŠ¤íƒˆë¡œ - ê°œë³„ ìœ ê¸°ì  ëª¨í•‘ + íŒŒí‹°í´ ì‹œìŠ¤í…œ ì‹œì‘!');
        }

        function draw() {
            clear();

            
            
            // ë°°ê²½ íŒŒí‹°í´ ì—…ë°ì´íŠ¸ ë° ê·¸ë¦¬ê¸°
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                p.update();
                p.display();
                
                if (p.isDead()) {
                    particles.splice(i, 1);
                }
            }
            
            // ëœë¤ íŒŒí‹°í´ ìƒì„±
            if (frameCount % 2 === 0 && particles.length < 100) {
                particles.push(new Particle(random(canvasWidth), -10));
            }
            
            // ì¶©ê²©íŒŒ ì—…ë°ì´íŠ¸ ë° ê·¸ë¦¬ê¸°
            for (let i = shockwaves.length - 1; i >= 0; i--) {
                let shock = shockwaves[i];
                shock.update();
                shock.display();
                
                if (shock.isDead()) {
                    shockwaves.splice(i, 1);
                }
            }
            
            // í¬ë¦¬ìŠ¤íƒˆ ê·¸ë¦¬ê¸°
            for (let i = 0; i < crystals.length; i++) {
                push();
                translate(crystals[i].x, crystals[i].y);
                
                if (activeCrystal === i) {
                    scale(1.03);
                }
                
                scale(crystals[i].scale);
                
                // ê° í¬ë¦¬ìŠ¤íƒˆë³„ ê³ ìœ í•œ ëª¨í•‘ ë°©ì‹
                if (i === 0) {
                    drawCrystalType1_GeometricFlow(i, crystalProgress[i]);
                } else if (i === 1) {
                    drawCrystalType2_OrganicBloom(i, crystalProgress[i]);
                } else {
                    drawCrystalType3_FluidMelt(i, crystalProgress[i]);
                }
                
                pop();
            }
            
            // ë§ˆìš°ìŠ¤ íŒŒí‹°í´ ì—…ë°ì´íŠ¸ ë° ê·¸ë¦¬ê¸°
            for (let i = mouseParticles.length - 1; i >= 0; i--) {
                let p = mouseParticles[i];
                p.update();
                p.display();
                
                if (p.isDead()) {
                    mouseParticles.splice(i, 1);
                }
            }

        
            
            // ë§ˆìš°ìŠ¤ ì´ë™ ì‹œ íŒŒí‹°í´ ìƒì„±
            let mouseSpeed = dist(mouseX, mouseY, lastMouseX, lastMouseY);
            if (mouseSpeed > 2 && frameCount % 1 === 0 && mouseParticles.length < 30) {
                mouseParticles.push(new MouseParticle(mouseX + random(-10, 10), mouseY + random(-10, 10)));
            }
            
            lastMouseX = mouseX;
            lastMouseY = mouseY;
            
            // ìŠ¤í¬ë¡¤ ì†ë„ ê°ì‡ 
            scrollVelocity *= 0.9;
        }

        // ë§ˆìš°ìŠ¤ í´ë¦­ ì‹œ ì¶©ê²©íŒŒ ìƒì„±
        function mousePressed() {
            shockwaves.push(new Shockwave(mouseX, mouseY));
            
            // ì¶©ê²©íŒŒ ì¤‘ì‹¬ì—ì„œ íŒŒí‹°í´ í­ë°œ
            for (let i = 0; i < 40; i++) {
                let p = new Particle(mouseX, mouseY);
                let angle = random(TWO_PI);
                let force = random(5, 15);
                p.vx = cos(angle) * force;
                p.vy = sin(angle) * force;
                particles.push(p);
            }
        }

        // ì¶©ê²©íŒŒ ì—…ë°ì´íŠ¸ ë° ê·¸ë¦¬ê¸° (ê¸°ì¡´ ì½”ë“œ ëë¶€ë¶„)
// ...

// ğŸŒŸ ì—¬ê¸°ì— ì¶”ê°€: ë§ˆìš°ìŠ¤ ê·¼ì²˜ ë°°ê²½ ì™œê³¡ íš¨ê³¼
push();
for (let i = 0; i < 20; i++) {
    let angle = (i / 20) * TWO_PI;
    let distance = 80 + sin(frameCount * 0.03 + i) * 20;
    let x = mouseX + cos(angle) * distance;
    let y = mouseY + sin(angle) * distance;
    
    let alpha = 30 - (distance / 4);
    fill(100, 149, 237, alpha);
    noStroke();
    ellipse(x, y, 3, 3);
}
pop();

// í¬ë¦¬ìŠ¤íƒˆ ê·¸ë¦¬ê¸° (ê¸°ì¡´ ì½”ë“œ)
for (let i = 0; i < crystals.length; i++) {
    // ...
}

        // ìŠ¤í¬ë¡¤ ì´ë²¤íŠ¸ ì²˜ë¦¬
        window.addEventListener('wheel', (e) => {
            scrollVelocity = e.deltaY * 0.1;
            
            // ìŠ¤í¬ë¡¤ ì‹œ íŒŒí‹°í´ ìƒì„±
            if (abs(scrollVelocity) > 2) {
                for (let i = 0; i < 80; i++) {
                    let p = new Particle(random(canvasWidth), random(canvasHeight));
                    p.vy += scrollVelocity * 0.5;
                    particles.push(p);
                }
            }
        });

        // í¬ë¦¬ìŠ¤íƒˆ 1: ê¸°í•˜í•™ì  íë¦„ ë³€í™˜ (íŒ¨í„´ â†’ í¬ë¦¬ìŠ¤íƒˆ â†’ íë¥´ëŠ” í˜•íƒœ â†’ ì•„ì´ìŠ¤í¬ë¦¼)
        function drawCrystalType1_GeometricFlow(index, progress) {
            let crystal = crystals[index];
            
            let targetColors = [100, 149, 237];
            let morphedColor = [
                lerp(crystal.color[0], targetColors[0], easeInOutCubic(progress)),
                lerp(crystal.color[1], targetColors[1], easeInOutCubic(progress)),
                lerp(crystal.color[2], targetColors[2], easeInOutCubic(progress))
            ];

            // Phase 0: ë³µì¡í•œ ê²©ì íŒ¨í„´ (0-0.2)
            if (progress <= 0.25) {
                let patternProgress = map(progress, 0, 0.25, 1, 0);
                let crystalProgress = map(progress, 0.15, 0.25, 0, 1);
                
                if (patternProgress > 0) {
                    drawComplexGridPattern(crystal, morphedColor, patternProgress);
                }
                if (crystalProgress > 0 && progress >= 0.15) {
                    let alpha = map(crystalProgress, 0, 1, 0, 180);
                    drawOriginalSVG(index, crystal, morphedColor, alpha);
                }
            }
            
            // Phase 1ê³¼ 2ê°€ ê²¹ì¹˜ë„ë¡ (0.25-0.55 êµ¬ê°„ì—ì„œ ë¸”ë Œë”©)
            else if (progress <= 0.55) {
                let alpha = progress <= 0.3 ? map(progress, 0.25, 0.3, 180, 255) : 
                            map(progress, 0.4, 0.55, 255, 0);
                if (alpha > 0) {
                    drawOriginalSVG(index, crystal, morphedColor, alpha);
                }
                
                if (progress >= 0.35) {
                    let flowProgress = map(progress, 0.35, 0.55, 0, 1);
                    let flowAlpha = map(progress, 0.35, 0.55, 0, 255);
                    
                    push();
                    tint(255, flowAlpha);
                    drawGeometricFlow(crystal, morphedColor, flowProgress);
                    pop();
                }
            }
            
            // Phase 3: íë¦„ì´ ëª¨ì—¬ì„œ ë‘¥ê·¼ í˜•íƒœ í˜•ì„± (0.55-0.75)
            else if (progress <= 0.75) {
                let gatherProgress = map(progress, 0.55, 0.75, 0, 1);
                drawFlowGathering(crystal, morphedColor, gatherProgress);
            }
            
            // Phase 4: ìµœì¢… ì•„ì´ìŠ¤í¬ë¦¼ í˜•ì„± (0.75-0.9)ë¡œ ë³€ê²½
else if (progress <= 0.9) {
    let finalProgress = map(progress, 0.75, 0.9, 0, 1);
    drawLemonIceCream(finalProgress);
}
// Phase 5: PNG ì´ë¯¸ì§€ë¡œ ëª¨í•‘ (0.9-1.0) ì¶”ê°€
else {
    let pngProgress = map(progress, 0.9, 1.0, 0, 1);
    drawPNGMorphing(0, pngProgress); // ì²« ë²ˆì§¸ í¬ë¦¬ìŠ¤íƒˆìš© PNG
}
        }

        // ë³µì¡í•œ ê²©ì íŒ¨í„´ (í¬ë¦¬ìŠ¤íƒˆ 1ìš©)
        function drawComplexGridPattern(crystal, color, progress) {
            push();
            
            let time = frameCount * 0.02;
            let gridSize = 20;
            let cellSize = 4.5;
            let centerOffset = gridSize * cellSize * 0.5;
            
            // ë©”ì¸ ê²©ì
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    let x = i * cellSize - centerOffset;
                    let y = j * cellSize - centerOffset;
                    
                    // ê±°ë¦¬ ê¸°ë°˜ ì›¨ì´ë¸Œ
                    let dist = sqrt(x * x + y * y);
                    let wave = sin(dist * 0.1 + time) * 0.5 + 0.5;
                    
                    // ì²´ì»¤ë³´ë“œ íŒ¨í„´
                    let checker = (i + j) % 2;
                    let intensity = checker * wave * progress;
                    
                    // ìˆ˜ì •: cornflower ê¸°ë°˜ìœ¼ë¡œ í†µì¼
let baseR = 100, baseG = 149, baseB = 237; // cornflower
let r = baseR + sin(time + i * 0.3) * 20 * intensity;
let g = baseG + cos(time + j * 0.3) * 20 * intensity;
let b = baseB + sin(time + (i + j) * 0.2) * 20 * intensity;
                    
                    fill(r, g, b, 255 * intensity * progress);
                    noStroke();
                    
                    // íšŒì „í•˜ëŠ” ì‚¬ê°í˜•
                    push();
                    translate(x, y);
                    rotate(time + dist * 0.02);
                    rect(-cellSize * 0.3, -cellSize * 0.3, cellSize * 0.6, cellSize * 0.6);
                    pop();
                }
            }
            
            // ë³´ì¡° ì›í˜• íŒ¨í„´
            for (let ring = 1; ring <= 4; ring++) {
                let radius = ring * 12;
                let segments = ring * 6;
                
                for (let i = 0; i < segments; i++) {
                    let angle = (i / segments) * TWO_PI;
                    let x = cos(angle + time * ring * 0.1) * radius;
                    let y = sin(angle + time * ring * 0.1) * radius;
                    
                    let pulsePhase = time + ring + i * 0.5;
                    let pulse = sin(pulsePhase) * 0.5 + 0.5;
                    
                    fill(color[0], color[1], color[2], 150 * pulse * progress);
                    noStroke();
                    ellipse(x, y, 3 + pulse * 2, 3 + pulse * 2);
                }
            }
            
            // ì¤‘ì•™ ë³µì¡í•œ ë§Œë‹¤ë¼ íŒ¨í„´
            push();
            translate(0, 0);
            
            for (let layer = 0; layer < 3; layer++) {
                let layerRadius = (layer + 1) * 12;
                let spokes = (layer + 1) * 8;
                
                for (let i = 0; i < spokes; i++) {
                    let spokeAngle = (i / spokes) * TWO_PI + time * (layer + 1) * 0.15;
                    
                    push();
                    rotate(spokeAngle);
                    
                    // ë³µì¡í•œ ê¸°í•˜í•™ì  í˜•íƒœ
                    for (let segment = 0; segment < 3; segment++) {
                        let segmentDist = layerRadius + segment * 5;
                        let segmentSize = 2 + segment;
                        
                        let oscillation = sin(time * 2 + layer + segment + i) * 0.5 + 0.5;
                        
                        // ìˆ˜ì •:
fill(
    100 + oscillation * 30,
    149 + oscillation * 30,
    237 + oscillation * 30,
    200 * oscillation * progress
);
                        
                        // ë‹¤ì–‘í•œ í˜•íƒœ
                        if ((i + segment) % 3 === 0) {
                            ellipse(0, segmentDist, segmentSize, segmentSize);
                        } else if ((i + segment) % 3 === 1) {
                            rect(-segmentSize/2, segmentDist - segmentSize/2, segmentSize, segmentSize);
                        } else {
                            // ì‚¼ê°í˜•
                            beginShape();
                            vertex(0, segmentDist - segmentSize/2);
                            vertex(-segmentSize/2, segmentDist + segmentSize/2);
                            vertex(segmentSize/2, segmentDist + segmentSize/2);
                            endShape(CLOSE);
                        }
                    }
                    
                    pop();
                }
            }
            
            pop();
            
            pop();
        }

        // í¬ë¦¬ìŠ¤íƒˆ 2: ìœ ê¸°ì²´ ê°œí™” ë³€í™˜ (íŒ¨í„´ â†’ í¬ë¦¬ìŠ¤íƒˆ â†’ ê½ƒìì²˜ëŸ¼ í¼ì³ì§ â†’ ì•„ì´ìŠ¤í¬ë¦¼)
        function drawCrystalType2_OrganicBloom(index, progress) {
            let crystal = crystals[index];
            
            let targetColors = [100, 149, 237];
            let morphedColor = [
                lerp(crystal.color[0], targetColors[0], easeInOutCubic(progress)),
                lerp(crystal.color[1], targetColors[1], easeInOutCubic(progress)),
                lerp(crystal.color[2], targetColors[2], easeInOutCubic(progress))
            ];
            
            // Phase 0: ë™ì‹¬ì› íŒŒë™ íŒ¨í„´ (0-0.2)
            if (progress <= 0.25) {
                let patternProgress = map(progress, 0, 0.25, 1, 0);
                let crystalProgress = map(progress, 0.15, 0.25, 0, 1);
                
                if (patternProgress > 0) {
                    drawConcentricWavePattern(crystal, morphedColor, patternProgress);
                }
                if (crystalProgress > 0 && progress >= 0.15) {
                    let alpha = map(crystalProgress, 0, 1, 0, 200);
                    drawOriginalSVG(index, crystal, morphedColor, alpha);
                }
            }
            
            // Phase 1: ì›ë³¸ SVG (0.25-0.4)
            else if (progress <= 0.45) {
                let alpha = map(progress, 0.25, 0.45, 200, 200);
                drawOriginalSVG(index, crystal, morphedColor, alpha);
            }
            
            // Phase 2: ì¤‘ì‹¬ì—ì„œ ê½ƒìì²˜ëŸ¼ í¼ì³ì§ (0.45-0.7)
            else if (progress <= 0.7) {
                let bloomProgress = map(progress, 0.45, 0.7, 0, 1);
                drawOrganicBloom(crystal, morphedColor, bloomProgress);
            }
            
            // Phase 3: ê½ƒìë“¤ì´ íšŒì „í•˜ë©° êµ¬í˜•ìœ¼ë¡œ ìˆ˜ë ´ (0.7-0.85)
            else if (progress <= 0.85) {
                let spiralProgress = map(progress, 0.7, 0.85, 0, 1);
                drawSpiralConvergence(crystal, morphedColor, spiralProgress);
            }
            
            // Phase 4: ìµœì¢… ì•„ì´ìŠ¤í¬ë¦¼ í˜•ì„± (0.85-0.95)ë¡œ ë³€ê²½
else if (progress <= 0.95) {
    let finalProgress = map(progress, 0.85, 0.95, 0, 1);
    drawStrawberryIceCream(morphedColor, finalProgress);
}
// Phase 5: PNG ì´ë¯¸ì§€ë¡œ ëª¨í•‘ (0.95-1.0) ì¶”ê°€
else {
    let pngProgress = map(progress, 0.95, 1.0, 0, 1);
    drawPNGMorphing(1, pngProgress); // ë‘ ë²ˆì§¸ í¬ë¦¬ìŠ¤íƒˆìš© PNG
}
        }

        // ë™ì‹¬ì› íŒŒë™ íŒ¨í„´ (í¬ë¦¬ìŠ¤íƒˆ 2ìš©)
        function drawConcentricWavePattern(crystal, color, progress) {
            push();
            
            let time = frameCount * 0.03;
            let maxRadius = 18;
            let rings = 12;
            
            // ë©”ì¸ ë™ì‹¬ì›ë“¤
            for (let ring = 0; ring < rings; ring++) {
                let radius = (ring + 1) * (maxRadius / rings);
                let wave = sin(time - ring * 0.3) * 0.5 + 0.5;
                let alpha = wave * progress * (1 - ring / rings);
                
                // ê° ë§ë§ˆë‹¤ ë‹¤ë¥¸ ì„¸ê·¸ë¨¼íŠ¸ ìˆ˜
                let segments = 18 + ring * 2;
                
                for (let i = 0; i < segments; i++) {
                    let angle = (i / segments) * TWO_PI + time * 0.5;
                    let x = cos(angle) * radius;
                    let y = sin(angle) * radius;
                    
                    // ì„¸ê·¸ë¨¼íŠ¸ë³„ í„ìŠ¤
                    let segmentPulse = sin(time * 2 + i * 0.2 + ring) * 0.5 + 0.5;
                    
                    let finalAlpha = alpha * segmentPulse;
                    
                    fill(
                        color[0] + ring * 5,
                        color[1] + ring * 5,
                        color[2] + ring * 5,
                        255 * finalAlpha
                    );
                    noStroke();
                    
                    ellipse(x, y, 2 + segmentPulse * 2, 2 + segmentPulse * 2);
                }
            }
            
            // ë°©ì‚¬í˜• ìŠ¤í¬í¬ íŒ¨í„´
            let spokes = 30;
            for (let i = 0; i < spokes; i++) {
                let spokeAngle = (i / spokes) * TWO_PI + time * 0.2;
                let spokeWave = sin(time * 3 + i * 0.5) * 0.5 + 0.5;
                
                push();
                rotate(spokeAngle);
                
                // ìŠ¤í¬í¬ë¥¼ ë”°ë¼ ì ë“¤ ë°°ì¹˜
                for (let dist = 8; dist < maxRadius; dist += 8) {
                    let distWave = sin(time * 1.5 + dist * 0.1) * 0.5 + 0.5;
                    let pointAlpha = spokeWave * distWave * progress;
                    
                    fill(color[0], color[1], color[2], 150 * pointAlpha);
                    ellipse(0, dist, 1.5, 1.5);
                }
                
                pop();
            }
            
            // ì¤‘ì•™ ë³µì¡í•œ ë‚˜ì„ 
            let spiralPoints = 150;
            for (let i = 0; i < spiralPoints; i++) {
                let spiralProgress = i / spiralPoints;
                let spiralRadius = spiralProgress * 30;
                let spiralAngle = spiralProgress * PI * 6 + time;
                
                let x = cos(spiralAngle) * spiralRadius;
                let y = sin(spiralAngle) * spiralRadius;
                
                let spiralPulse = sin(time * 4 + i * 0.1) * 0.5 + 0.5;
                
                fill(
                    color[0] + spiralPulse * 30,
                    color[1] + spiralPulse * 30,
                    color[2] + spiralPulse * 30,
                    200 * spiralPulse * progress
                );
                noStroke();
                ellipse(x, y, 2 + spiralPulse, 2 + spiralPulse);
            }
            
            // ì™¸ê³½ íŒŒë™ íš¨ê³¼
            let outerWaves = 6;
            for (let wave = 0; wave < outerWaves; wave++) {
                let waveRadius = maxRadius + wave * 10;
                let waveIntensity = sin(time - wave * 0.8) * 0.5 + 0.5;
                
                if (waveIntensity > 0.3) {
                    strokeWeight(1 + waveIntensity * 2);
                    stroke(color[0], color[1], color[2], 100 * waveIntensity * progress);
                    noFill();
                    ellipse(0, 0, waveRadius * 2, waveRadius * 2);
                }
            }
            
            pop();
        }

        // í¬ë¦¬ìŠ¤íƒˆ 3: ìœ ì²´ ìš©í•´ ë³€í™˜ (íŒ¨í„´ â†’ í¬ë¦¬ìŠ¤íƒˆ â†’ ì•¡ì²´ì²˜ëŸ¼ í˜ëŸ¬ í•©ì³ì§ â†’ ì•„ì´ìŠ¤í¬ë¦¼)
        function drawCrystalType3_FluidMelt(index, progress) {
            let crystal = crystals[index];
            
            let targetColors = [100, 149, 237];
            let morphedColor = [
                lerp(crystal.color[0], targetColors[0], easeInOutCubic(progress)),
                lerp(crystal.color[1], targetColors[1], easeInOutCubic(progress)),
                lerp(crystal.color[2], targetColors[2], easeInOutCubic(progress))
            ];
            
            // Phase 0: ì‚¼ê°í˜• í…Œì…€ë ˆì´ì…˜ íŒ¨í„´ (0-0.25)
            if (progress <= 0.25) {
                let patternProgress = map(progress, 0, 0.25, 1, 0);
                let crystalProgress = map(progress, 0.15, 0.25, 0, 1);
                
                if (patternProgress > 0) {
                    drawTriangularTessellationPattern(crystal, morphedColor, patternProgress);
                }
                if (crystalProgress > 0 && progress >= 0.15) {
                    let alpha = map(crystalProgress, 0, 1, 0, 180);
                    drawOriginalSVG(index, crystal, morphedColor, alpha);
                }
            }
            
            // Phase 1: ì›ë³¸ SVG (0.25-0.4)
            else if (progress <= 0.43) {
                let alpha = map(progress, 0.25, 0.43, 180, 180);
                drawOriginalSVG(index, crystal, morphedColor, alpha);
            }
            
            // Phase 2: ì‚¼ê°í˜• ì¡°ê°ë“¤ì´ ì•¡ì²´ì²˜ëŸ¼ ë…¹ì•„ë‚´ë¦¼ (0.43-0.65)
            else if (progress <= 0.65) {
                let meltProgress = map(progress, 0.43, 0.65, 0, 1);
                drawFluidMelt(crystal, morphedColor, meltProgress);
            }
            
            // Phase 3: ì•¡ì²´ê°€ í‘œë©´ì¥ë ¥ìœ¼ë¡œ êµ¬í˜• í˜•ì„± (0.65-0.8)
            else if (progress <= 0.8) {
                let surfaceProgress = map(progress, 0.65, 0.8, 0, 1);
                drawSurfaceTension(crystal, morphedColor, surfaceProgress);
            }
            
            // Phase 4: ìµœì¢… ì•„ì´ìŠ¤í¬ë¦¼ í˜•ì„± (0.8-0.9)ë¡œ ë³€ê²½
else if (progress <= 0.9) {
    let finalProgress = map(progress, 0.8, 0.9, 0, 1);
    drawBlueberryIceCream(morphedColor, finalProgress);
}
// Phase 5: PNG ì´ë¯¸ì§€ë¡œ ëª¨í•‘ (0.9-1.0) ì¶”ê°€
else {
    let pngProgress = map(progress, 0.9, 1.0, 0, 1);
    drawPNGMorphing(2, pngProgress); // ì„¸ ë²ˆì§¸ í¬ë¦¬ìŠ¤íƒˆìš© PNG
}
        }

        // ì‚¼ê°í˜• í…Œì…€ë ˆì´ì…˜ íŒ¨í„´ (í¬ë¦¬ìŠ¤íƒˆ 3ìš©)
        function drawTriangularTessellationPattern(crystal, color, progress) {
            push();
            
            let time = frameCount * 0.025;
            let triangleSize = 3; // ë” ì‘ê²Œ
            let rows = 20; // ë” ì ê²Œ
            let cols = 20; // ë” ì ê²Œ
            
            // í—ˆë‹ˆì»´ ìŠ¤íƒ€ì¼ ì‚¼ê°í˜• ê²©ì - íŒŒí‹°í´ì²˜ëŸ¼
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    let isEvenRow = row % 2 === 0;
                    let offsetX = isEvenRow ? 0 : triangleSize * 0.5;
                    
                    let x = (col - cols/2) * triangleSize + offsetX;
                    let y = (row - rows/2) * triangleSize * 0.866; // sqrt(3)/2
                    
                    // ê±°ë¦¬ ê¸°ë°˜ ì• ë‹ˆë©”ì´ì…˜
                    let dist = sqrt(x * x + y * y);
                    let wave = sin(dist * 0.15 + time * 2) * 0.5 + 0.5;
                    
                    // ì‚¼ê°í˜• ë°©í–¥ (ìœ„/ì•„ë˜)
                    let isUpward = (row + col) % 2 === 0;
                    
                    // í¬ë¦¬ìŠ¤íƒˆë¡œ ìˆ˜ë ´í•˜ëŠ” íš¨ê³¼
                    let convergence = map(progress, 0.7, 1, 0, 1);
                    convergence = constrain(convergence, 0, 1);
                    
                    // í¬ë¦¬ìŠ¤íƒˆì˜ ì‚¼ê°í˜• ì¡°ê° ìœ„ì¹˜ë¡œ ìˆ˜ë ´
                    let trianglePositions = [
                        {x: -20, y: -25}, {x: 15, y: -20}, {x: -10, y: 5}, 
                        {x: 25, y: 10}, {x: 0, y: 30}, {x: -30, y: 15}
                    ];
                    let targetIndex = (row * cols + col) % trianglePositions.length;
                    let target = trianglePositions[targetIndex];
                    
                    let finalX = lerp(x, target.x, convergence);
                    let finalY = lerp(y, target.y, convergence);
                    
                    // ë™ì  ìƒ‰ìƒê³¼ í¬ê¸°
                    let colorShift = sin(time + row * 0.3 + col * 0.2) * 20;
                    let sizeMultiplier = 0.6 + wave * 0.3; // ë” ì‘ê²Œ
                    
                    fill(
                        color[0] + colorShift,
                        color[1] + colorShift * 0.8,
                        color[2] + colorShift * 1.2,
                        200 * wave * progress
                    );
                    noStroke();
                    
                    push();
                    translate(finalX, finalY);
                    rotate(time * 0.5 + dist * 0.02);
                    scale(sizeMultiplier);
                    
                    // ì‚¼ê°í˜• ê·¸ë¦¬ê¸° - ë” ì‘ê²Œ
                    let size = triangleSize * 0.6; // ë” ì‘ê²Œ
                    beginShape();
                    if (isUpward) {
                        vertex(0, -size * 0.577); // ê¼­ì§“ì ì´ ìœ„
                        vertex(-size * 0.5, size * 0.289);
                        vertex(size * 0.5, size * 0.289);
                    } else {
                        vertex(0, size * 0.577); // ê¼­ì§“ì ì´ ì•„ë˜
                        vertex(-size * 0.5, -size * 0.289);
                        vertex(size * 0.5, -size * 0.289);
                    }
                    endShape(CLOSE);
                    
                    pop();
                }
            }
            
            // ì¤‘ì•™ ë³µì¡í•œ í”„ë™íƒˆ ì‚¼ê°í˜• - ë” ì‘ê²Œ
            push();
            translate(0, 0);
            
            for (let level = 0; level < 3; level++) { // ë” ì ê²Œ
                let levelSize = (level + 1) * 8; // ë” ì‘ê²Œ
                let triangles = pow(2, level); // ë” ì ê²Œ
                
                // í¬ë¦¬ìŠ¤íƒˆë¡œ ìˆ˜ë ´
                let convergence = map(progress, 0.8, 1, 0, 1);
                convergence = constrain(convergence, 0, 1);
                
                for (let i = 0; i < triangles; i++) {
                    let angle = (i / triangles) * TWO_PI + time * (level + 1) * 0.1;
                    let radius = levelSize + sin(time + level + i) * 3; // ë” ì‘ê²Œ
                    
                    let finalRadius = radius * (1 - convergence * 0.7);
                    
                    let x = cos(angle) * finalRadius;
                    let y = sin(angle) * finalRadius;
                    
                    let pulse = sin(time * 3 + level + i * 0.5) * 0.5 + 0.5;
                    
                    fill(
                        color[0] + pulse * 30,
                        color[1] + pulse * 20,
                        color[2] + pulse * 15,
                        150 * pulse * progress
                    );
                    
                    push();
                    translate(x, y);
                    rotate(angle + time);
                    scale(0.4 + pulse * 0.2); // ë” ì‘ê²Œ
                    
                    // ì‘ì€ ì‚¼ê°í˜•
                    beginShape();
                    vertex(0, -2.5); // ë” ì‘ê²Œ
                    vertex(-2.2, 1.25);
                    vertex(2.2, 1.25);
                    endShape(CLOSE);
                    
                    pop();
                }
            }
            
            // ë°©ì‚¬í˜• ì‚¼ê°í˜• ìŠ¤í¬í¬ - ë” ì‘ê²Œ
            let spokes = 12; // ë” ì ê²Œ
            for (let i = 0; i < spokes; i++) {
                let spokeAngle = (i / spokes) * TWO_PI + time * 0.3;
                let spokeWave = sin(time * 2 + i) * 0.5 + 0.5;
                push();
                rotate(spokeAngle);
                
                for (let dist = 15; dist < 60; dist += 12) {
                    let distWave = sin(time * 1.5 + dist * 0.1 + i) * 0.5 + 0.5;
                    let triangleAlpha = spokeWave * distWave * progress;
                    
                    if (triangleAlpha > 0.1) {
                        push();
                        translate(0, dist);
                        rotate(dist * 0.1 + time);
                        
                        fill(color[0], color[1], color[2], 150 * triangleAlpha);
                        noStroke();
                        
                        beginShape();
                        vertex(0, -3);
                        vertex(-2.6, 1.5);
                        vertex(2.6, 1.5);
                        endShape(CLOSE);
                        
                        pop();
                    }
                }
                
                pop();
            }
            
            // ì™¸ê³½ íšŒì „í•˜ëŠ” ì‚¼ê°í˜• ë§
            for (let ring = 0; ring < 3; ring++) {
                let ringRadius = 20 + ring * 10;
                let ringTriangles = 8 + ring * 4;
                let ringRotation = time * (ring + 1) * 0.2;
                
                for (let i = 0; i < ringTriangles; i++) {
                    let angle = (i / ringTriangles) * TWO_PI + ringRotation;
                    let x = cos(angle) * ringRadius;
                    let y = sin(angle) * ringRadius;
                    
                    let ringPulse = sin(time * 2 + ring + i * 0.3) * 0.5 + 0.5;
                    
                    if (ringPulse > 0.2) {
                        push();
                        translate(x, y);
                        rotate(angle + time * 2);
                        scale(0.6 + ringPulse * 0.4);
                        
                        fill(
                            color[0] + ring * 10,
                            color[1] + ring * 10,
                            color[2] + ring * 10,
                            100 * ringPulse * progress
                        );
                        noStroke();
                        
                        beginShape();
                        vertex(0, -4);
                        vertex(-3.46, 2);
                        vertex(3.46, 2);
                        endShape(CLOSE);
                        
                        pop();
                    }
                }
            }
            
            pop();
        }

        function drawGeometricFlow(crystal, color, progress) {
    push();
    
    // ì›ë³¸ ì§ì‚¬ê°í˜•ë“¤ì˜ ìœ„ì¹˜ì—ì„œ ì‹œì‘
    let rects = [
        {x: -15, y: -30, w: 20, h: 35},
        {x: 5, y: -10, w: 35, h: 20},
        {x: -25, y: -10, w: 35, h: 20},
        {x: -10, y: 10, w: 20, h: 35}
    ];
    
    // ì•ˆì „í•œ ì§„í–‰ ë‹¨ê³„ ê³„ì‚°
    let phase1 = Math.min(Math.max(progress * 2.5, 0), 1); // ì´ˆê¸° ìš©í•´
    let phase2 = Math.min(Math.max((progress - 0.3) * 2.5, 0), 1); // íë¦„
    let phase3 = Math.min(Math.max((progress - 0.6) * 2.5, 0), 1); // ì•¡í™”
    
    for (let i = 0; i < rects.length; i++) {
        push();
        
        let flowDirection = i % 2 === 0 ? 1 : -1;
        let rectSeed = i * 1.5; // ë‹¨ìˆœí™”ëœ ì‹œë“œ
        
        // 1ë‹¨ê³„: í˜•íƒœ ìš©í•´
        let dissolve = phase1 * phase1; // ì œê³±ìœ¼ë¡œ ë¶€ë“œëŸ¬ìš´ ê°€ì†
        let cornerRadius = 8 + dissolve * rects[i].w * 0.6;
        
        // ë¯¸ì„¸í•œ ì§„ë™
        let shake = Math.sin(frameCount * 0.05 + rectSeed) * dissolve * 1.5;
        
        // 2ë‹¨ê³„: íë¦„ íš¨ê³¼
        let flow = phase2 * phase2;
        let flowY = flow * (15 + i * 5) + Math.sin(frameCount * 0.03 + rectSeed) * flow * 2;
        let flowX = Math.sin(frameCount * 0.08 + rectSeed) * 4 * flowDirection * flow + shake;
        
        // 3ë‹¨ê³„: ë³€í˜•
        let liquid = phase3 * phase3;
        let stretchY = 1 + flow * (1.2 + Math.sin(rectSeed) * 0.2);
        let stretchX = 1 - liquid * (0.3 + Math.cos(frameCount * 0.02 + rectSeed) * 0.1);
        
        // ì¤‘ì‹¬ìœ¼ë¡œ ìˆ˜ë ´
        if (liquid > 0) {
            let pullX = rects[i].x > 0 ? -liquid * 3 : liquid * 3;
            flowX += pullX;
        }
        
        // íšŒì „
        let rotation = flow * 20 * flowDirection + Math.sin(frameCount * 0.02 + rectSeed) * 8;
        
        // ìƒ‰ìƒ ë³€í™”
        let colorShift = Math.sin(progress * Math.PI + rectSeed) * 12;
        let alpha = 220 - progress * 40 + Math.sin(frameCount * 0.03 + rectSeed) * 8;
        
        fill(color[0] + colorShift, color[1] + colorShift * 0.5, color[2] - colorShift * 0.3, alpha);
        noStroke();
        
        translate(rects[i].x + flowX, rects[i].y + flowY);
        rotate(rotation * Math.PI / 180);
        scale(stretchX, stretchY);
        
        rect(-rects[i].w/2, -rects[i].h/2, rects[i].w, rects[i].h, cornerRadius);
        
        pop();
    }
    
    pop();
}

function drawFlowGathering(crystal, color, progress) {
    push();
    
    // ì•ˆì „í•œ ë‹¨ê³„ ê³„ì‚°
    let gather1 = Math.min(Math.max(progress * 3, 0), 1);
    let gather2 = Math.min(Math.max((progress - 0.2) * 2.5, 0), 1);
    let gather3 = Math.min(Math.max((progress - 0.5) * 2, 0), 1);
    
    // ë¯¸ì„¸ íŒŒí‹°í´
    let particleCount = Math.floor(15 * (1 - gather1));
    for (let j = 0; j < particleCount; j++) {
        let angle = j * 24 + frameCount * 0.3;
        let distance = 40 * (1 - gather1) + Math.sin(frameCount * 0.06 + j) * 3;
        let size = 2.5 * (1 - gather1) + Math.sin(frameCount * 0.1 + j) * 0.5;
        
        if (size > 0.5) {
            let px = Math.cos(angle * Math.PI / 180) * distance;
            let py = Math.sin(angle * Math.PI / 180) * distance * 0.8 + 12;
            
            let alpha = (1 - gather1) * 80 + Math.sin(frameCount * 0.05 + j) * 15;
            fill(color[0], color[1], color[2], alpha);
            ellipse(px, py, size, size * 1.1);
        }
    }
    
    // ë©”ì¸ ë°©ìš¸ë“¤
    for (let i = 0; i < 6; i++) {
        let angle = i * 60;
        let convergence = gather2 * gather2;
        let distance = 25 * (1 - gather1) - convergence * 12;
        
        // ë°©ìš¸ ê°„ ìƒí˜¸ì‘ìš© (ë‹¨ìˆœí™”)
        let interaction = Math.sin(frameCount * 0.04 + i) * (1 - convergence) * 1.5;
        
        let x = Math.cos(angle * Math.PI / 180) * distance + interaction;
        let y = Math.sin(angle * Math.PI / 180) * distance * 0.7 + 8;
        
        // í¬ê¸°ì™€ ë³€í˜•
        let baseSize = 12 + gather1 * 25;
        let pulse = Math.sin(frameCount * 0.08 + i) * 2;
        let size = baseSize + pulse;
        let stretch = 1.1 + Math.sin(frameCount * 0.06 + i) * 0.1 + convergence * 0.15;
        
        let alpha = 120 + gather1 * 80 + Math.sin(frameCount * 0.04 + i) * 12;
        fill(color[0], color[1], color[2], alpha);
        ellipse(x, y, size, size * stretch);
    }
    
    // ì¤‘ì‹¬ ìœµí•© ë©ì–´ë¦¬
    if (gather3 > 0) {
        let fusion = gather3 * gather3;
        let coreSize = 20 + fusion * 50;
        
        // ë‚´ë¶€ ì›€ì§ì„
        let moveX = Math.sin(frameCount * 0.025) * fusion * 1.5;
        let moveY = Math.cos(frameCount * 0.02) * fusion * 1;
        
        // í‘œë©´ íŒŒë™
        let wave = Math.sin(frameCount * 0.05) * fusion * 2.5;
        let finalSize = coreSize + wave;
        
        // ë©”ì¸ ë°”ë””
        fill(color[0], color[1], color[2], 180 + fusion * 35);
        ellipse(moveX, 6 + moveY, finalSize, finalSize * 1.08);
        
        // í•˜ì´ë¼ì´íŠ¸
        if (fusion > 0.3) {
            let highlight = (fusion - 0.3) / 0.7;
            let hlSize = finalSize * (0.55 + Math.sin(frameCount * 0.04) * 0.05);
            
            fill(color[0] + 20, color[1] + 12, color[2] + 15, highlight * 70);
            ellipse(moveX - 2, 3 + moveY, hlSize, hlSize * 1.02);
        }
        
        // ì™¸ë¶€ ê¸€ë¡œìš°
        if (fusion > 0.7) {
            let glow = (fusion - 0.7) / 0.3;
            fill(color[0], color[1], color[2], glow * 25);
            ellipse(moveX, 6 + moveY, finalSize * 1.2, finalSize * 1.25);
        }
    }
    
    pop();
}

function drawOrganicBloom(crystal, color, progress) {
    push();
    
    // 7ë‹¨ê³„ë¡œ ë” ì„¸ë¶„í™”í•˜ì—¬ ë¶€ë“œëŸ¬ìš´ ì—°ê²°
    let phase1 = constrain(map(progress, 0, 0.15, 0, 1), 0, 1);      // ë°œì•„
    let phase2 = constrain(map(progress, 0.1, 0.3, 0, 1), 0, 1);     // ì´ˆê¸°ì„±ì¥  
    let phase3 = constrain(map(progress, 0.25, 0.5, 0, 1), 0, 1);    // ì¤‘ê¸°ì„±ì¥
    let phase4 = constrain(map(progress, 0.45, 0.7, 0, 1), 0, 1);    // ê°œí™”
    let phase5 = constrain(map(progress, 0.65, 0.85, 0, 1), 0, 1);   // ì™„ì„±
    let phase6 = constrain(map(progress, 0.8, 0.95, 0, 1), 0, 1);    // ì„±ìˆ™
    let phase7 = constrain(map(progress, 0.9, 1, 0, 1), 0, 1);       // ë³€í™”
    
    // ì „ì²´ì ì¸ ìœ ê¸°ì  ì›€ì§ì„ - í¬ê¸° ì œí•œ
    let globalRotation = progress * 15 + 
                        sin(frameCount * 0.015) * 6 + 
                        cos(frameCount * 0.012) * 3;
    rotate(radians(globalRotation));
    
    // ì „ì²´ ìŠ¤ì¼€ì¼ - ì›ë³¸ í¬ê¸° ìœ ì§€í•˜ë©´ì„œ ë¯¸ì„¸í•œ í˜¸í¡
    let globalScale = 0.85 + sin(frameCount * 0.025) * 0.08 + 
                     cos(frameCount * 0.018) * 0.05;
    scale(globalScale);
    
    // ë°°ê²½ ë¯¸ì„¸ íŒŒí‹°í´ë“¤ (ë” ë§ê³  ì‘ê²Œ)
    if (phase2 > 0) {
        drawMicroParticles(color, phase2, phase3, phase4);
    }
    
    // ì¤‘ì‹¬ ì—ë„ˆì§€ ì½”ì–´ (ì§€ì†ì ìœ¼ë¡œ ì§„í™”)
    drawEvolvingCore(color, phase1, phase2, phase3, phase4, phase5, phase6, phase7);
    
    // ë‚´ë¶€ ì—ë„ˆì§€ ë§ (Phase 1ë¶€í„°)
    if (phase1 > 0) {
        drawEnergyRings(color, phase1, phase2, phase3);
    }
    
    // ë©”ì¸ ê½ƒì ì‹œìŠ¤í…œ - 4ê°œ ë ˆì´ì–´, í¬ê¸° ì œí•œ
    for (let layer = 0; layer < 4; layer++) {
        let layerDelay = layer * 0.08; // ë” ì´˜ì´˜í•œ íƒ€ì´ë°
        let layerProgress = constrain(progress - layerDelay, 0, 1);
        
        if (layerProgress <= 0) continue;
        
        push();
        
        // ê° ë ˆì´ì–´ë³„ ìœ ê¸°ì  íšŒì „
        let layerRotSpeed = 0.008 + layer * 0.003;
        let layerRotation = frameCount * layerRotSpeed + layer * 12 + 
                           sin(frameCount * 0.01 + layer) * 4;
        rotate(radians(layerRotation));
        
        let petalCount = 10 - layer; // 10, 9, 8, 7ê°œ
        
        for (let i = 0; i < petalCount; i++) {
            push();
            
            // ë” ë³µì¡í•˜ê³  ì—°ê²°ëœ ê°ë„ ì‹œìŠ¤í…œ
            let baseAngle = i * (360 / petalCount);
            let neighborInfluence = sin(i * 0.8 + frameCount * 0.02) * 
                                   cos((i-1) * 0.6 + frameCount * 0.015) * 5;
            let layerInfluence = sin(layer * 0.4 + frameCount * 0.01) * 3;
            let globalFlow = cos(frameCount * 0.008 + i * 0.3) * 2;
            
            let organicWave = neighborInfluence + layerInfluence + globalFlow;
            let angle = baseAngle + organicWave * (1.2 - layerProgress * 0.3);
            
            // ê°œë³„ ìš”ì†Œë“¤ì˜ ìƒí˜¸ ì—°ê²°ëœ íƒ€ì´ë°
            let selfTiming = sin(i * 0.9 + layer * 0.5) * 0.15;
            let neighborTiming = cos((i + layer) * 0.7) * 0.1;
            let globalTiming = sin(progress * PI + layer) * 0.05;
            
            let adjustedProgress = constrain(layerProgress + selfTiming + 
                                           neighborTiming + globalTiming, 0, 1);
            
            // ê±°ë¦¬ ê³„ì‚° - í¬ê¸° ì œí•œí•˜ë©´ì„œ ì—­ë™ì 
            let baseDistance = 12 + layer * 6; // ì›ë³¸ë³´ë‹¤ ì‘ê²Œ
            let phaseDistance = 0;
            
            if (phase1 > 0) phaseDistance += easeInOutQuart(phase1) * baseDistance * 0.2;
            if (phase2 > 0) phaseDistance += easeInOutCubic(phase2) * baseDistance * 0.4;
            if (phase3 > 0) phaseDistance += easeOutBounce(phase3) * baseDistance * 0.3;
            if (phase4 > 0) phaseDistance += phase4 * baseDistance * 0.1;
            
            // ë‹¤ì¤‘ ì§„ë™ íš¨ê³¼ (ì„œë¡œ ì—°ê²°ë¨)
            let mainPulse = sin(frameCount * 0.025 + i * 0.4 + layer) * 0.12;
            let subPulse = cos(frameCount * 0.035 + i * 0.6 - layer) * 0.08;
            let microPulse = sin(frameCount * 0.045 + i * 0.2) * 0.04;
            let breathEffect = (mainPulse + subPulse + microPulse) + 1;
            
            phaseDistance *= breathEffect;
            
            // ê½ƒì í¬ê¸° - ì œí•œí•˜ë©´ì„œ ë‹¤ì–‘ì„±
            let basePetalLength = 25 + layer * 8 + sin(i * 0.6 + layer) * 6;
            let basePetalWidth = 10 + layer * 4 + cos(i * 0.8 - layer) * 3;
            
            // ë‹¨ê³„ë³„ ì„±ì¥ ê³¡ì„ 
            let growthCurve = adjustedProgress;
            if (phase3 > 0) growthCurve *= (1 + phase3 * 0.2);
            if (phase5 > 0) growthCurve *= (1 + sin(phase5 * PI) * 0.15);
            
            let petalLength = basePetalLength * growthCurve;
            let petalWidth = basePetalWidth * growthCurve;
            
            // ë³µí•©ì ì¸ ê¸°ìš¸ì„ê³¼ ë¹„í‹€ë¦¼
            let baseTilt = sin(adjustedProgress * PI + i * 0.7 + layer * 0.3) * 12;
            let dynamicTilt = cos(frameCount * 0.02 + i * 0.5) * 4;
            let layerTilt = sin(frameCount * 0.015 + layer) * 2;
            let neighborTilt = cos(i * 0.9 + frameCount * 0.01) * 
                              sin((i+1) * 0.8 + frameCount * 0.012) * 3;
            
            let totalTilt = baseTilt + dynamicTilt + layerTilt + neighborTilt;
            
            // Phase 6-7ì—ì„œ ë‚´í–¥ì  ìˆ˜ë ´
            if (phase6 > 0) {
                let convergence = phase6 * 0.2;
                totalTilt += (180 - angle) * convergence * 0.1;
                phaseDistance *= (1 - convergence * 0.3);
            }
            
            // 3D ê¹Šì´ì™€ ì›ê·¼ê°
            let baseDepth = 1 + sin(adjustedProgress * PI + i * 0.5) * 0.12;
            let dynamicDepth = cos(frameCount * 0.02 + i * 0.3 + layer) * 0.06;
            let finalDepth = baseDepth + dynamicDepth;
            
            rotate(radians(angle + totalTilt));
            scale(finalDepth, 1 + sin(frameCount * 0.01 + i) * 0.03);
            translate(0, -phaseDistance);
            
            // ì§„í™”í•˜ëŠ” ìƒ‰ìƒ ì‹œìŠ¤í…œ
            let timeColor = frameCount * 0.5;
            let layerHue = layer * 8;
            let positionHue = i * 3;
            let phaseHue = progress * 20;
            
            let dynamicR = sin(timeColor * 0.01 + i * 0.1) * 10;
            let dynamicG = cos(timeColor * 0.012 + layer * 0.2) * 8;
            let dynamicB = sin(timeColor * 0.008 + i * 0.15 + layer * 0.1) * 12;
            
            let petalColor = [
                constrain(color[0] + layerHue + dynamicR, 0, 255),
                constrain(color[1] + phaseHue + dynamicG - layerHue * 0.3, 0, 255),
                constrain(color[2] + positionHue + dynamicB + phase7 * 15, 0, 255)
            ];
            
            // ì•ŒíŒŒ ê°’ - ë ˆì´ì–´ ë¸”ë Œë”©
            let baseAlpha = 180 - layer * 25;
            let phaseAlpha = phase4 * 40 + phase5 * 20;
            let centerAlpha = baseAlpha + phaseAlpha;
            let edgeAlpha = (120 + layer * 15 + phase3 * 30) * (1 + phase6 * 0.3);
            
            drawAdvancedPetal(petalColor, petalLength, petalWidth, 
                            centerAlpha, edgeAlpha, i, layer, adjustedProgress, phase7);
            
            pop();
        }
        
        pop();
    }
    
    // ì¤‘ê°„ ì—°ê²° ìš”ì†Œë“¤
    if (phase3 > 0) {
        drawConnectiveElements(color, phase3, phase4, phase5);
    }
    
    // ë™ì  ì—ë„ˆì§€ í•„ë“œ (Phase 4ë¶€í„°)
    if (phase4 > 0) {
        drawEnergyField(color, phase4, phase5, phase6);
    }
    
    // ì™¸ë¶€ ê³µëª… íŒ¨í„´ (Phase 5ë¶€í„°)
    if (phase5 > 0) {
        drawResonancePattern(color, phase5, phase6, phase7);
    }
    
    // ì „ì´ íš¨ê³¼ (Phase 7)
    if (phase7 > 0) {
        drawTransitionEffects(color, phase7);
    }
    
    pop();
}

function drawMicroParticles(color, phase2, phase3, phase4) {
    let particleCount = 35;
    for (let i = 0; i < particleCount; i++) {
        push();
        
        let baseAngle = i * (360 / particleCount);
        let orbitRadius = 45 + sin(frameCount * 0.03 + i) * 15;
        let spiralOffset = frameCount * (1 + i * 0.1) * 0.8;
        let angle = baseAngle + spiralOffset;
        
        let x = cos(radians(angle)) * orbitRadius;
        let y = sin(radians(angle)) * orbitRadius;
        
        // ê°œë³„ ì§„ë™
        x += sin(frameCount * 0.08 + i * 0.3) * 3;
        y += cos(frameCount * 0.06 + i * 0.4) * 2;
        
        translate(x, y);
        
        let size = (1.5 + sin(frameCount * 0.12 + i) * 0.8) * phase2;
        let alpha = (120 + cos(frameCount * 0.05 + i) * 40) * phase2 * (1 + phase3 * 0.4);
        
        fill(color[0] + 25, color[1] + 15, color[2] - 5, alpha);
        noStroke();
        ellipse(0, 0, size, size);
        
        // ì—°ê²°ì„  íš¨ê³¼
        if (phase4 > 0 && i % 3 === 0) {
            stroke(color[0] + 40, color[1] + 20, color[2] + 10, 60 * phase4);
            strokeWeight(0.8);
            line(0, 0, -x * 0.3, -y * 0.3);
        }
        
        pop();
    }
}

function drawEvolvingCore(color, p1, p2, p3, p4, p5, p6, p7) {
    push();
    
    // ë‹¤ì¸µ ì½”ì–´ ì‹œìŠ¤í…œ
    for (let coreLayer = 0; coreLayer < 5; coreLayer++) {
        push();
        
        let layerScale = 1 - coreLayer * 0.15;
        let layerRotation = frameCount * (0.8 + coreLayer * 0.3) + coreLayer * 20;
        rotate(radians(layerRotation));
        
        // ê° ë‹¨ê³„ë³„ í¬ê¸° ì§„í™”
        let baseSize = 6 + coreLayer * 3;
        let phaseSize = baseSize;
        
        if (p1 > 0) phaseSize *= (0.3 + p1 * 0.7);
        if (p2 > 0) phaseSize *= (1 + p2 * 0.3);
        if (p4 > 0) phaseSize *= (1 + p4 * 0.2);
        if (p6 > 0) phaseSize *= (1 + sin(p6 * PI) * 0.25);
        
        // ë™ì  ë°ê¸°
        let brightness = 30 + coreLayer * 15;
        if (p3 > 0) brightness += p3 * 25;
        if (p5 > 0) brightness += p5 * 20;
        if (p7 > 0) brightness += sin(p7 * PI * 2) * 30;
        
        fill(Math.min(255, color[0] + brightness),
             Math.min(255, color[1] + brightness * 0.8),
             Math.min(255, color[2] + brightness * 0.6),
             200 - coreLayer * 25);
        
        // í˜•íƒœ ì§„í™”
        if (p7 > 0.3) {
            // ë³µì¡í•œ í˜•íƒœë¡œ ë³€í™”
            beginShape();
            for (let angle = 0; angle < 360; angle += 12) {
                let radius = phaseSize * layerScale;
                let var1 = sin(angle * 0.4 + frameCount * 0.02 + coreLayer) * 2;
                let var2 = cos(angle * 0.6 + frameCount * 0.015) * 1.5;
                radius += (var1 + var2) * p7;
                
                let x = cos(radians(angle)) * radius;
                let y = sin(radians(angle)) * radius;
                vertex(x, y);
            }
            endShape(CLOSE);
        } else {
            // í„ìŠ¤ íš¨ê³¼
            let pulse = 1 + sin(frameCount * 0.04 + coreLayer) * 0.1;
            ellipse(0, 0, phaseSize * layerScale * pulse, phaseSize * layerScale * pulse);
        }
        
        pop();
    }
    
    pop();
}

function drawEnergyRings(color, phase1, phase2, phase3) {
    push();
    
    let ringCount = 3;
    for (let ring = 0; ring < ringCount; ring++) {
        push();
        
        let ringRadius = 20 + ring * 12;
        let ringRotation = frameCount * (0.5 + ring * 0.2) + ring * 45;
        rotate(radians(ringRotation));
        
        let segmentCount = 8 + ring * 2;
        let segmentSize = (2 + ring) * phase1 * (1 + phase2 * 0.5);
        
        for (let seg = 0; seg < segmentCount; seg++) {
            push();
            
            let segAngle = seg * (360 / segmentCount);
            rotate(radians(segAngle));
            translate(0, -ringRadius);
            
            let alpha = (100 + ring * 30) * phase1 * (1 + phase3 * 0.6);
            fill(color[0] + ring * 20, color[1] + ring * 10, color[2] - ring * 5, alpha);
            
            let dynamicSize = segmentSize * (1 + sin(frameCount * 0.06 + seg + ring) * 0.3);
            ellipse(0, 0, dynamicSize, dynamicSize);
            
            pop();
        }
        
        pop();
    }
    
    pop();
}

function drawAdvancedPetal(petalColor, petalLength, petalWidth, centerAlpha, edgeAlpha, index, layer, progress, phase7) {
    // ë‹¤ì¸µ ê·¸ë¼ë°ì´ì…˜ ê½ƒì
    for (let subLayer = 0; subLayer < 4; subLayer++) {
        let layerScale = 1 - subLayer * 0.15;
        let layerAlpha = (centerAlpha - subLayer * 30) * layerScale;
        
        fill(petalColor[0] + subLayer * 12, 
             petalColor[1] + subLayer * 8, 
             petalColor[2] - subLayer * 4, 
             layerAlpha);
        
        noStroke();
        
        // ê³ ë„ë¡œ ìœ ê¸°ì ì¸ ê½ƒì ëª¨ì–‘
        beginShape();
        vertex(0, 0);
        
        let segments = 16;
        for (let seg = 0; seg <= segments; seg++) {
            let t = seg / segments;
            let baseX = lerp(-petalWidth/2, petalWidth/2, Math.abs(t - 0.5) * 2) * layerScale;
            let baseY = -petalLength * sin(t * PI) * layerScale;
            
            // 5ê°œì˜ ì„œë¡œ ë‹¤ë¥¸ íŒŒí˜•ì´ ê²°í•©
            let wave1 = sin(t * PI * 5 + frameCount * 0.04 + index) * 1.5;
            let wave2 = cos(t * PI * 7 + frameCount * 0.03 + layer) * 1;
            let wave3 = sin(t * PI * 3 + frameCount * 0.05) * 0.8;
            let wave4 = cos(t * PI * 9 + frameCount * 0.025 + index * 0.5) * 0.6;
            let wave5 = sin(t * PI * 11 + frameCount * 0.035) * 0.4;
            
            let totalWave = (wave1 + wave2 + wave3 + wave4 + wave5) * progress * (1 - subLayer * 0.2);
            baseX += totalWave;
            
            // ëë¶€ë¶„ ì •ë°€ ì¡°ì •
            if (t > 0.7) {
                let tipFactor = map(t, 0.7, 1, 1, 0.2 + phase7 * 0.3);
                baseX *= tipFactor;
            }
            
            // ë¯¸ì„¸í•œ ë“¤ì­‰ë‚ ì­‰í•¨
            let microVariation = sin(t * PI * 20 + frameCount * 0.1 + index + layer) * 0.3 * progress;
            baseX += microVariation;
            
            vertex(baseX, baseY);
        }
        endShape(CLOSE);
    }
    
    // ë³µìˆ˜ í•˜ì´ë¼ì´íŠ¸ ì‹œìŠ¤í…œ
    if (progress > 0.4) {
        for (let highlight = 0; highlight < 5; highlight++) {
            let hPos = 0.3 + highlight * 0.15;
            let hSize = petalWidth * (0.08 + highlight * 0.02);
            let hAlpha = edgeAlpha * 0.4 * (1 - highlight * 0.15);
            
            fill(Math.min(255, petalColor[0] + 50 + highlight * 10), 
                 Math.min(255, petalColor[1] + 40 + highlight * 8), 
                 Math.min(255, petalColor[2] + 30 + highlight * 6), 
                 hAlpha);
            
            let hX = sin(highlight * 0.8 + frameCount * 0.08) * petalWidth * 0.15;
            let hY = -petalLength * hPos;
            ellipse(hX, hY, hSize, hSize);
        }
    }
}

function drawConnectiveElements(color, phase3, phase4, phase5) {
    push();
    
    // ê½ƒìë“¤ì„ ì—°ê²°í•˜ëŠ” ì—ë„ˆì§€ ìŠ¤íŠ¸ë¦¼
    let streamCount = 12;
    for (let i = 0; i < streamCount; i++) {
        push();
        
        let angle = i * 30 + frameCount * 0.8;
        rotate(radians(angle));
        
        noFill();
        stroke(color[0] + 30, color[1] + 20, color[2] + 10, 80 * phase3 * (1 + phase4 * 0.5));
        strokeWeight(1 + phase5 * 0.8);
        
        beginShape();
        for (let point = 0; point < 8; point++) {
            let t = point / 7;
            let radius = lerp(8, 35, t);
            let waveOffset = sin(t * PI * 2 + frameCount * 0.06 + i) * 4;
            
            let x = (radius + waveOffset) * cos(radians(t * 30));
            let y = -(radius + waveOffset) * sin(radians(t * 30));
            
            if (point === 0) {
                curveVertex(x, y);
            }
            curveVertex(x, y);
            if (point === 7) {
                curveVertex(x, y);
            }
        }
        endShape();
        
        pop();
    }
    
    pop();
}

function drawEnergyField(color, phase4, phase5, phase6) {
    push();
    
    // ë™ì  ì—ë„ˆì§€ í•„ë“œ
    let fieldPoints = 24;
    for (let i = 0; i < fieldPoints; i++) {
        push();
        
        let angle = i * (360 / fieldPoints) + frameCount * 0.6;
        let baseRadius = 50;
        let radiusVar = sin(frameCount * 0.04 + i * 0.3) * 8;
        let radius = baseRadius + radiusVar;
        
        let x = cos(radians(angle)) * radius;
        let y = sin(radians(angle)) * radius;
        
        translate(x, y);
        
        let fieldSize = (2 + sin(frameCount * 0.1 + i) * 1) * phase4;
        let fieldAlpha = 60 * phase4 * (1 + phase5 * 0.7);
        
        fill(color[0] + 40, color[1] + 25, color[2] + 15, fieldAlpha);
        ellipse(0, 0, fieldSize, fieldSize);
        
        // ì—°ê²°ì„ 
        if (phase6 > 0) {
            stroke(color[0] + 50, color[1] + 30, color[2] + 20, 40 * phase6);
            strokeWeight(0.8);
            let nextI = (i + 1) % fieldPoints;
            let nextAngle = nextI * (360 / fieldPoints) + frameCount * 0.6;
            let nextX = cos(radians(nextAngle)) * (baseRadius + sin(frameCount * 0.04 + nextI * 0.3) * 8);
            let nextY = sin(radians(nextAngle)) * (baseRadius + sin(frameCount * 0.04 + nextI * 0.3) * 8);
            line(0, 0, nextX - x, nextY - y);
        }
        
        pop();
    }
    
    pop();
}

function drawResonancePattern(color, phase5, phase6, phase7) {
    push();
    
    // ê³µëª… íŒ¨í„´
    let resonanceRings = 4;
    for (let ring = 0; ring < resonanceRings; ring++) {
        push();
        
        let ringRadius = 60 + ring * 15;
        let ringRotation = frameCount * (0.3 + ring * 0.1) * (1 + phase6 * 0.5);
        rotate(radians(ringRotation));
        
        noFill();
        stroke(color[0] + ring * 10, color[1] + ring * 5, color[2] - ring * 3, 
               (40 - ring * 8) * phase5 * (1 + phase7 * 0.8));
        strokeWeight(1 + ring * 0.3);
        
        beginShape();
        for (let angle = 0; angle < 360; angle += 8) {
            let radius = ringRadius;
            let resonance = sin(angle * 0.1 + frameCount * 0.02 + ring) * 5 * phase5;
            radius += resonance;
            
            let x = cos(radians(angle)) * radius;
            let y = sin(radians(angle)) * radius;
            vertex(x, y);
        }
        endShape(CLOSE);
        
        pop();
    }
    
    pop();
}

function drawTransitionEffects(color, phase7) {
    push();
    
    // ì „ì´ íš¨ê³¼ - ë‹¤ìŒ í˜•íƒœë¡œì˜ ë³€í™˜ ì¤€ë¹„
    let transitionCount = 16;
    for (let i = 0; i < transitionCount; i++) {
        push();
        
        let angle = i * (360 / transitionCount) + frameCount * 2;
        let distance = 30 + sin(frameCount * 0.05 + i) * 20;
        
        let x = cos(radians(angle)) * distance;
        let y = sin(radians(angle)) * distance;
        
        translate(x, y);
        rotate(radians(angle + frameCount * 3));
        
        let size = 3 * phase7 * (1 + sin(frameCount * 0.12 + i) * 0.5);
        let alpha = 120 * phase7;
        
        fill(color[0] + 60, color[1] + 40, color[2] + 20, alpha);
        
        // ì‘ì€ ë‚˜ì„ í˜•
        beginShape();
        for (let spiralAngle = 0; spiralAngle < 180; spiralAngle += 30) {
            let spiralRadius = size * (spiralAngle / 180);
            let sx = cos(radians(spiralAngle)) * spiralRadius;
            let sy = sin(radians(spiralAngle)) * spiralRadius;
            vertex(sx, sy);
        }
        endShape();
        
        pop();
    }
    
    pop();
}

// ê°œì„ ëœ ì´ì§• í•¨ìˆ˜ë“¤
function easeInOutCubic(t) {
    return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
}

function easeInOutQuart(t) {
    return t < 0.5 ? 8 * t * t * t * t : 1 - Math.pow(-2 * t + 2, 4) / 2;
}

function easeOutBounce(t) {
    const n1 = 7.5625;
    const d1 = 2.75;
    
    if (t < 1 / d1) {
        return n1 * t * t;
    } else if (t < 2 / d1) {
        return n1 * (t -= 1.5 / d1) * t + 0.75;
    } else if (t < 2.5 / d1) {
        return n1 * (t -= 2.25 / d1) * t + 0.9375;
    } else {
        return n1 * (t -= 2.625 / d1) * t + 0.984375;
    }
}

        function drawSpiralConvergence(crystal, color, progress) {
            // ì•ˆì „ì„± ì²´í¬
            if (!crystal || !color || progress < 0 || progress > 1) {
                return;
            }
            
            push();
            
            try {
                let spiralEase = easeInOutQuart(progress);
                
                // Phase 2ì—ì„œ ì´ì–´ë°›ì€ ìš”ì†Œë“¤ì„ ì´ˆë°˜ì— ìœ ì§€
                let inheritancePhase = progress < 0.3 ? map(progress, 0, 0.3, 1, 0) : 0;
                
                // Phase 2ì˜ ê½ƒì ì”ì¬ (ì´ˆë°˜ì—ë§Œ í‘œì‹œ)
                if (inheritancePhase > 0) {
                    for (let i = 0; i < 8; i++) {
                        push();
                        
                        let angle = i * 45;
                        let distance = 15 * inheritancePhase;
                        let size = 10 * inheritancePhase;
                        
                        rotate(radians(angle));
                        translate(0, -distance);
                        
                        fill(color[0] + 20, color[1] + 15, color[2] - 5, 100 * inheritancePhase);
                        ellipse(0, 0, size, size);
                        
                        pop();
                    }
                }
                
                // ë©”ì¸ ë‚˜ì„  ìˆ˜ë ´ íš¨ê³¼ (0.2-0.4 êµ¬ê°„ìœ¼ë¡œ ë‹¨ì¶•)
                let mainProgress = progress > 0.2 && progress < 0.4 ? 
                    map(progress, 0.2, 0.4, 0, 1) : 0;
                
                if (mainProgress > 0) {
                    let particleCount = Math.floor(constrain(lerp(8, 12, mainProgress), 1, 20));
                    
                    for (let i = 0; i < particleCount; i++) {
                        push();
                        
                        let baseAngle = (i / particleCount) * 360;
                        let spiralAngle = baseAngle + mainProgress * 180 * (i % 2 === 0 ? 1 : -1);
                        let distance = lerp(45, 8, easeInOutCubic(mainProgress));
                        let size = lerp(15, 25, mainProgress);
                        
                        let yRotation = spiralAngle * 0.5 + frameCount * 0.5;
                        let scaleX = 1 + cos(radians(yRotation)) * 0.12;
                        let scaleY = 1 + sin(radians(yRotation)) * 0.08;
                        
                        let x = cos(radians(spiralAngle)) * distance;
                        let y = sin(radians(spiralAngle)) * distance;
                        
                        translate(x, y);
                        rotate(radians(spiralAngle * 0.2));
                        scale(scaleX, scaleY);
                        
                        let rotationColor = [
                            constrain(color[0] + sin(spiralAngle * PI/180) * 20, 0, 255),
                            constrain(color[1] + cos(spiralAngle * PI/180) * 15, 0, 255),
                            constrain(color[2] + sin(spiralAngle * PI/180 + PI/3) * 10, 0, 255)
                        ];
                        
                        fill(rotationColor[0], rotationColor[1], rotationColor[2], 
                             constrain(150 + mainProgress * 60, 0, 255));
                        noStroke();
                        
                        beginShape();
                        for (let angle = 0; angle < 360; angle += 25) {
                            let radius = size * 0.5;
                            let organicVariation = sin(angle * 0.15 + frameCount * 0.04 + i) * 1.5;
                            radius += organicVariation;
                            
                            let px = cos(radians(angle)) * radius;
                            let py = sin(radians(angle)) * radius;
                            vertex(px, py);
                        }
                        endShape(CLOSE);
                        
                        pop();
                    }
                }
                
                // ì•„ì´ìŠ¤í¬ë¦¼ìœ¼ë¡œì˜ ë³€í˜• ê³¼ì • (0.4-1.0 êµ¬ê°„) - Phase 4ì™€ ì •í™•íˆ ì¼ì¹˜!
                if (progress > 0.4) {
                    let iceCreamProgress = constrain(map(progress, 0.4, 1, 0, 1), 0, 1);
                    let scale = 0.7; // drawStrawberryIceCreamê³¼ ë™ì¼
                    
                    // Phase 4ì—ì„œ ì‚¬ìš©í•˜ëŠ” ê²ƒê³¼ ë™ì¼í•œ íˆ¬ëª…ë„ ê³„ì‚°
                    let safeProgress = Math.max(0.3, iceCreamProgress);
                    let finalAlpha = progress >= 0.9 ? 1.0 : constrain(0.6 + iceCreamProgress * 0.4, 0.6, 1.0);
                    
                    // 1. ì»µ ë¶€ë¶„ - drawStrawberryIceCreamê³¼ ì •í™•íˆ ë™ì¼í•œ ë¡œì§
                    let cupProgress = safeProgress > 0.1 ? map(safeProgress, 0.1, 0.4, 0, 1) : 0.7;
                    
                    // ì´ˆë¡ìƒ‰ ì»µ ë² ì´ìŠ¤ - ì¢Œí‘œì™€ ìƒ‰ìƒ ì •í™•íˆ ì¼ì¹˜
                    fill(77, 255, 168, constrain(255 * cupProgress * finalAlpha, 0, 255));
                    noStroke();
                    
                    beginShape();
                    vertex(-55 * scale, 20 * scale);      // ì™¼ìª½ ìƒë‹¨
                    vertex(55 * scale, 20 * scale);       // ì˜¤ë¥¸ìª½ ìƒë‹¨  
                    vertex(35 * scale, 80 * scale);       // ì˜¤ë¥¸ìª½ í•˜ë‹¨
                    vertex(-35 * scale, 80 * scale);      // ì™¼ìª½ í•˜ë‹¨
                    endShape(CLOSE);
                    
                    // ì¤„ë¬´ëŠ¬ - drawStrawberryIceCreamê³¼ ì •í™•íˆ ë™ì¼
                    push();
                    
                    if (typeof drawingContext !== 'undefined' && drawingContext.save) {
                        drawingContext.save();
                        
                        beginShape();
                        vertex(-55 * scale, 20 * scale);
                        vertex(55 * scale, 20 * scale);
                        vertex(35 * scale, 80 * scale);
                        vertex(-35 * scale, 80 * scale);
                        endShape();
                        
                        if (drawingContext.clip) {
                            drawingContext.clip();
                        }
                        
                        fill(100, 149, 237, constrain(255 * cupProgress * finalAlpha, 0, 255));
                        let stripeWidth = 5.75 * scale;
                        let stripeSpacing = 14.7 * scale;
                        
                        for (let i = -8; i < 10; i++) {
                            push();
                            translate(i * stripeSpacing - 50 * scale, -50 * scale);
                            rotate(radians(-17.5));
                            rect(0, 0, stripeWidth, 300 * scale);
                            pop();
                        }
                        
                        if (drawingContext.restore) {
                            drawingContext.restore();
                        }
                    }
                    
                    pop();
                    
                    // 2. ìŠ¤ì¿±ë“¤ - drawStrawberryIceCreamê³¼ ì •í™•íˆ ë™ì¼í•œ í˜•íƒœì™€ ì¢Œí‘œ
                    let scoopProgress = safeProgress > 0.3 ? map(safeProgress, 0.3, 0.8, 0, 1) : 0.6;
                    
                    // ì²« ë²ˆì§¸ ìŠ¤ì¿± (Cornflower Blue) - ì¢Œí‘œì™€ í˜•íƒœ ì •í™•íˆ ì¼ì¹˜
                    push();
                    fill(100, 149, 237, constrain(255 * scoopProgress * finalAlpha, 0, 255));
                    noStroke();
                    
                    // drawStrawberryIceCreamê³¼ ì •í™•íˆ ë™ì¼í•œ ì¢Œí‘œ
                    beginShape();
                    curveVertex(-55 * scale, 12 * scale);
                    curveVertex(-58 * scale, 12 * scale);
                    curveVertex(-52 * scale, -5 * scale);
                    curveVertex(-30 * scale, -18 * scale);
                    curveVertex(-42 * scale, -25 * scale);
                    curveVertex(-38 * scale, -32 * scale);
                    curveVertex(-32 * scale, -38 * scale);
                    curveVertex(-25 * scale, -42 * scale);
                    curveVertex(-18 * scale, -44 * scale);
                    curveVertex(-10 * scale, -46 * scale);
                    curveVertex(-2 * scale, -45 * scale);
                    curveVertex(5 * scale, -42 * scale);
                    curveVertex(10 * scale, -38 * scale);
                    curveVertex(14 * scale, -32 * scale);
                    curveVertex(17 * scale, -25 * scale);
                    curveVertex(19 * scale, -18 * scale);
                    curveVertex(22 * scale, -10 * scale);
                    curveVertex(23 * scale, -2 * scale);
                    curveVertex(22 * scale, 5 * scale);
                    curveVertex(20 * scale, 12 * scale);
                    curveVertex(16 * scale, 17 * scale);
                    curveVertex(10 * scale, 20 * scale);
                    curveVertex(2 * scale, 22 * scale);
                    curveVertex(-8 * scale, 21 * scale);
                    curveVertex(-18 * scale, 20 * scale);
                    curveVertex(-28 * scale, 19 * scale);
                    curveVertex(-38 * scale, 17 * scale);
                    curveVertex(-45 * scale, 15 * scale);
                    curveVertex(-55 * scale, 12 * scale);
                    curveVertex(-55 * scale, 12 * scale);
                    endShape();
                    pop();
                    
                    // ë‘ ë²ˆì§¸ ìŠ¤ì¿± (Yellow) - drawStrawberryIceCreamê³¼ ì •í™•íˆ ë™ì¼
                    if (scoopProgress > 0.4 || safeProgress >= 0.3) {
                        let yellowProgress = scoopProgress > 0.4 ? map(scoopProgress, 0.4, 1, 0, 1) : 0.5;
                        
                        push();
                        
                        if (typeof drawingContext !== 'undefined' && drawingContext.globalCompositeOperation) {
                            drawingContext.globalCompositeOperation = 'multiply';
                        }
                        
                        fill(255, 255, 100, constrain(200 * yellowProgress * finalAlpha, 0, 255));
                        noStroke();
                        
                        // drawStrawberryIceCreamê³¼ ì •í™•íˆ ë™ì¼í•œ ì¢Œí‘œ
                        beginShape();
                        curveVertex(-20 * scale, 10 * scale);
                        curveVertex(-18 * scale, 5 * scale);
                        curveVertex(-12 * scale, 1 * scale);
                        curveVertex(-9 * scale, -5 * scale);
                        curveVertex(-10 * scale, -7 * scale);
                        curveVertex(-22 * scale, -15 * scale);
                        curveVertex(-20 * scale, -25 * scale);
                        curveVertex(-15 * scale, -32 * scale);
                        curveVertex(-8 * scale, -35 * scale);
                        curveVertex(0 * scale, -37 * scale);
                        curveVertex(5 * scale, -36 * scale);
                        curveVertex(8 * scale, -33 * scale);
                        curveVertex(15 * scale, -35 * scale);
                        curveVertex(25 * scale, -38 * scale);
                        curveVertex(35 * scale, -37 * scale);
                        curveVertex(42 * scale, -33 * scale);
                        curveVertex(48 * scale, -25 * scale);
                        curveVertex(52 * scale, -15 * scale);
                        curveVertex(53 * scale, -5 * scale);
                        curveVertex(50 * scale, 5 * scale);
                        curveVertex(45 * scale, 10 * scale);
                        curveVertex(48 * scale, 15 * scale);
                        curveVertex(45 * scale, 20 * scale);
                        curveVertex(40 * scale, 22 * scale);
                        curveVertex(32 * scale, 23 * scale);
                        curveVertex(22 * scale, 22 * scale);
                        curveVertex(12 * scale, 20 * scale);
                        curveVertex(2 * scale, 18 * scale);
                        curveVertex(-8 * scale, 17 * scale);
                        curveVertex(-15 * scale, 15 * scale);
                        curveVertex(-15 * scale, 15 * scale);
                        endShape();
                        
                        if (typeof drawingContext !== 'undefined' && drawingContext.globalCompositeOperation) {
                            drawingContext.globalCompositeOperation = 'source-over';
                        }
                        
                        pop();
                    }
                }
                
            } catch (error) {
                console.error('Error in drawSpiralConvergence:', error);
                // ì—ëŸ¬ ë°œìƒ ì‹œ ê¸°ë³¸ ì›í˜• ê·¸ë¦¬ê¸°
                fill(color[0], color[1], color[2], 100);
                ellipse(0, 0, 50, 50);
            }
            
            pop();
        }
        function drawFluidMelt(crystal, color, progress) {
    push();
    
    let meltEase = easeInOutCubic(progress);
    
    // ì‚¼ê°í˜•ë“¤ì´ ì„œë¡œ ì—°ê²°ë˜ì–´ ë³€í˜•ë˜ëŠ” êµ¬ì¡°
    let triangles = [
        {x: -20, y: -25, size: 18, connections: [1, 2], phase: 0},
        {x: 15, y: -20, size: 22, connections: [0, 3, 4], phase: 0.2},
        {x: -10, y: 5, size: 20, connections: [0, 5], phase: 0.1},
        {x: 25, y: 10, size: 16, connections: [1, 4], phase: 0.4},
        {x: 0, y: 30, size: 24, connections: [1, 3, 5], phase: 0.3},
        {x: -30, y: 15, size: 19, connections: [2, 4], phase: 0.5}
    ];
    
    // ì—°ê²°ì„ ë“¤ì„ ë¨¼ì € ê·¸ë ¤ì„œ ìœ ê¸°ì  ê´€ê³„ í‘œí˜„
    if (progress < 0.7) {
        drawConnections(triangles, color, progress);
    }
    
    for (let i = 0; i < triangles.length; i++) {
        push();
        
        let tri = triangles[i];
        let localProgress = constrain(progress - tri.phase * 0.3, 0, 1);
        let morphFactor = easeInOutCubic(localProgress);
        
        // ë” ë³µì¡í•œ ë¬¼ë¦¬ ì‹œë®¬ë ˆì´ì…˜
        let gravity = localProgress * localProgress * 25;
        let viscosity = sin(frameCount * 0.03 + i * 1.2) * 4 * (1 - morphFactor * 0.5);
        let turbulence = cos(frameCount * 0.07 + i * 0.8) * 2 * morphFactor;
        
        // ì£¼ë³€ ì‚¼ê°í˜•ë“¤ì˜ ì˜í–¥ìœ¼ë¡œ ìœ„ì¹˜ ì¡°ì • (ìœ ê¸°ì  ìƒí˜¸ì‘ìš©)
        let influenceX = 0, influenceY = 0;
        for (let conn of tri.connections) {
            let connTri = triangles[conn];
            let distance = dist(tri.x, tri.y, connTri.x, connTri.y);
            let force = (100 - distance) * 0.02 * progress;
            let angle = atan2(connTri.y - tri.y, connTri.x - tri.x);
            influenceX += cos(angle) * force;
            influenceY += sin(angle) * force;
        }
        
        let currentX = tri.x + viscosity + turbulence + influenceX;
        let currentY = tri.y + gravity * (1 + i * 0.08) + influenceY;
        
        translate(currentX, currentY);
        rotate(sin(frameCount * 0.02 + i) * 0.1 * morphFactor);
        
        // ìƒ‰ìƒì´ ì‹œê°„ì— ë”°ë¼ ìœ ê¸°ì ìœ¼ë¡œ ë³€í™”
        let colorShift = sin(frameCount * 0.05 + i * 0.7) * 10 * morphFactor;
        let alpha = 180 + progress * 50 + sin(frameCount * 0.04 + i) * 20;
        fill(
            constrain(color[0] + colorShift, 0, 255), 
            constrain(color[1] + colorShift * 0.5, 0, 255), 
            constrain(color[2] + colorShift * 0.3, 0, 255), 
            alpha
        );
        noStroke();
        
        if (morphFactor < 0.4) {
            // ì‚¼ê°í˜•ì´ ìœ ê¸°ì ìœ¼ë¡œ ë³€í˜•
            drawOrganicTriangle(tri.size, morphFactor, i);
        } else if (morphFactor < 0.8) {
            // ì „í™˜ ë‹¨ê³„ - ë³µì¡í•œ ìœ ê¸°ì²´ í˜•íƒœ
            drawTransitionBlob(tri.size, morphFactor, i);
        } else {
            // ìµœì¢… ë°©ìš¸ í˜•íƒœ
            drawOrganicDrop(tri.size, morphFactor, i, progress);
        }
        
        pop();
    }
    
    pop();
}

function drawConnections(triangles, color, progress) {
    if (progress > 0.6) return;
    
    stroke(color[0], color[1], color[2], 80 * (1 - progress * 1.5));
    strokeWeight(2 * (1 - progress));
    
    for (let i = 0; i < triangles.length; i++) {
        let tri = triangles[i];
        for (let connIndex of tri.connections) {
            if (connIndex > i) { // ì¤‘ë³µ ì—°ê²° ë°©ì§€
                let connTri = triangles[connIndex];
                
                // ë² ì§€ì–´ ê³¡ì„ ìœ¼ë¡œ ìœ ê¸°ì ì¸ ì—°ê²°ì„ 
                let midX = (tri.x + connTri.x) / 2;
                let midY = (tri.y + connTri.y) / 2;
                let controlOffset = sin(frameCount * 0.03 + i + connIndex) * 15;
                
                bezier(
                    tri.x, tri.y,
                    midX + controlOffset, midY - abs(controlOffset) * 0.5,
                    midX - controlOffset, midY + abs(controlOffset) * 0.5,
                    connTri.x, connTri.y
                );
            }
        }
    }
    noStroke();
}

function drawOrganicTriangle(size, morphFactor, index) {
    let vertices = 3;
    let baseRadius = size;
    
    beginShape();
    for (let j = 0; j < vertices; j++) {
        let angle = j * 120 - 90;
        
        // ê° ê¼­ì§“ì ì´ ë…ë¦½ì ìœ¼ë¡œ ë³€í˜•
        let radiusVariation = sin(frameCount * 0.04 + j * 2 + index) * 3 * morphFactor;
        let radius = baseRadius + radiusVariation;
        
        // ëª¨ì„œë¦¬ê°€ ì ì§„ì ìœ¼ë¡œ ë‘¥ê¸€ì–´ì§
        let roundness = morphFactor * 1.5;
        radius *= (1 + roundness * 0.2);
        
        let x = cos(radians(angle)) * radius;
        let y = sin(radians(angle)) * radius;
        
        if (morphFactor > 0.1) {
            // ë² ì§€ì–´ë¡œ ìœ ê¸°ì  ê³¡ì„  ìƒì„±
            let nextJ = (j + 1) % vertices;
            let nextAngle = nextJ * 120 - 90;
            let nextRadius = baseRadius + sin(frameCount * 0.04 + nextJ * 2 + index) * 3 * morphFactor;
            nextRadius *= (1 + roundness * 0.2);
            
            let nextX = cos(radians(nextAngle)) * nextRadius;
            let nextY = sin(radians(nextAngle)) * nextRadius;
            
            let controlDistance = radius * (0.5 + roundness * 0.3);
            let controlAngle = angle + 60;
            let controlX = cos(radians(controlAngle)) * controlDistance;
            let controlY = sin(radians(controlAngle)) * controlDistance;
            
            if (j === 0) vertex(x, y);
            quadraticVertex(controlX, controlY, nextX, nextY);
        } else {
            vertex(x, y);
        }
    }
    endShape(CLOSE);
}

function drawTransitionBlob(size, morphFactor, index) {
    // ë³µì¡í•œ ìœ ê¸°ì²´ ì¤‘ê°„ í˜•íƒœ
    let points = 12;
    let baseRadius = size * 0.8;
    
    beginShape();
    for (let i = 0; i < points; i++) {
        let angle = i * (360 / points);
        
        // ì—¬ëŸ¬ ì£¼íŒŒìˆ˜ì˜ íŒŒë™ì´ ê²°í•©ëœ ë³µì¡í•œ í˜•íƒœ
        let wave1 = sin(radians(angle * 3) + frameCount * 0.05 + index) * 4;
        let wave2 = cos(radians(angle * 5) + frameCount * 0.03 + index * 1.5) * 2;
        let wave3 = sin(radians(angle * 2) + frameCount * 0.07 + index * 0.7) * 3;
        
        let radius = baseRadius + wave1 + wave2 + wave3;
        radius *= (1 + morphFactor * 0.3);
        
        let x = cos(radians(angle)) * radius;
        let y = sin(radians(angle)) * radius;
        vertex(x, y);
    }
    endShape(CLOSE);
}

function drawOrganicDrop(size, morphFactor, index, globalProgress) {
    let dropSize = size * (0.9 + morphFactor * 0.3);
    
    // ë¬¼ë°©ìš¸ì´ ì‚´ì•„ìˆëŠ” ê²ƒì²˜ëŸ¼ ì›€ì§ì„
    let pulseSize = sin(frameCount * 0.06 + index * 1.3) * 0.05 + 1;
    let asymmetry = cos(frameCount * 0.04 + index * 0.9) * 0.1;
    
    beginShape();
    for (let angle = 0; angle < 360; angle += 8) {
        let radius = dropSize * 0.5 * pulseSize;
        
        // ë¬¼ë°©ìš¸ì˜ ìì—°ìŠ¤ëŸ¬ìš´ í˜•íƒœ
        if (angle > 150 && angle < 210) {
            radius *= 1.15; // ì•„ë˜ìª½ ë³¼ë¡
        } else if (angle > 30 && angle < 150) {
            radius *= 0.95; // ì˜†ë©´ ì•½ê°„ ë“¤ì–´ê°
        }
        
        // ë¯¸ì„¸í•œ í‘œë©´ ë–¨ë¦¼
        let surfaceTension = sin(angle * 4 + frameCount * 0.1 + index) * 0.02;
        radius *= (1 + surfaceTension);
        
        let x = cos(radians(angle)) * radius * (1 + asymmetry);
        let y = sin(radians(angle)) * radius * (1.05 - asymmetry * 0.5);
        vertex(x, y);
    }
    endShape(CLOSE);
    
    // ë™ì  í•˜ì´ë¼ì´íŠ¸
    if (globalProgress > 0.3) {
        let highlightIntensity = sin(frameCount * 0.08 + index) * 30 + 70;
        fill(
            Math.min(255, color[0] + highlightIntensity), 
            Math.min(255, color[1] + highlightIntensity), 
            Math.min(255, color[2] + highlightIntensity), 
            120
        );
        
        let highlightSize = dropSize * (0.25 + sin(frameCount * 0.05 + index) * 0.05);
        let offsetX = -dropSize * 0.15 + cos(frameCount * 0.03 + index) * 2;
        let offsetY = -dropSize * 0.2 + sin(frameCount * 0.04 + index) * 1;
        
        ellipse(offsetX, offsetY, highlightSize, highlightSize);
    }
}

function drawSurfaceTension(crystal, color, progress) {
    push();
    
    let tensionEase = easeInOutQuart(progress);
    
    // ë°©ìš¸ë“¤ì´ ì„œë¡œ ëŒì–´ë‹¹ê¸°ë©° í•©ì³ì§€ëŠ” ë³µì¡í•œ ì‹œìŠ¤í…œ
    let drops = [
        {angle: 0, distance: 35, size: 16, phase: 0},
        {angle: 45, distance: 32, size: 18, phase: 0.1},
        {angle: 90, distance: 38, size: 14, phase: 0.2},
        {angle: 135, distance: 30, size: 20, phase: 0.05},
        {angle: 180, distance: 33, size: 17, phase: 0.15},
        {angle: 225, distance: 36, size: 15, phase: 0.25},
        {angle: 270, distance: 31, size: 19, phase: 0.08},
        {angle: 315, distance: 34, size: 16, phase: 0.18}
    ];
    
    // ì¤‘ì‹¬ìœ¼ë¡œì˜ ì¸ë ¥ ê³„ì‚°
    let centralMass = progress * 100;
    
    for (let i = 0; i < drops.length; i++) {
        push();
        
        let drop = drops[i];
        let localProgress = constrain(progress - drop.phase, 0, 1);
        let attraction = easeInOutCubic(localProgress);
        
        // ë³µì¡í•œ ê¶¤ë„ ìš´ë™
        let spiralFactor = sin(frameCount * 0.04 + i * 0.8) * 5 * (1 - attraction);
        let currentDistance = lerp(drop.distance, 8, attraction);
        currentDistance += spiralFactor;
        
        let currentAngle = drop.angle + sin(frameCount * 0.02 + i) * 10 * (1 - attraction);
        
        let x = cos(radians(currentAngle)) * currentDistance;
        let y = sin(radians(currentAngle)) * currentDistance + 15;
        
        translate(x, y);
        
        // ë°©ìš¸ ê°„ ìƒí˜¸ì‘ìš©ìœ¼ë¡œ í¬ê¸° ë³€í™”
        let neighborInfluence = 0;
        for (let j = 0; j < drops.length; j++) {
            if (i !== j) {
                let otherDrop = drops[j];
                let otherX = cos(radians(otherDrop.angle)) * lerp(otherDrop.distance, 8, attraction);
                let otherY = sin(radians(otherDrop.angle)) * lerp(otherDrop.distance, 8, attraction) + 15;
                let distance = dist(x, y, otherX, otherY);
                
                if (distance < 20) {
                    neighborInfluence += (20 - distance) * 0.01;
                }
            }
        }
        
        let dropSize = drop.size * (1 - attraction * 0.4) * (1 + neighborInfluence);
        
        // í•©ì³ì§€ëŠ” ê³¼ì •ì—ì„œì˜ ë³€í˜•
        let stretchToCenter = attraction * 0.6;
        let centerAngle = atan2(-y, -x);
        let stretchX = 1 - stretchToCenter * 0.5;
        let stretchY = 1 + stretchToCenter * 0.8;
        
        rotate(centerAngle * stretchToCenter);
        scale(stretchX, stretchY);
        
        // ë™ì  ìƒ‰ìƒ ë³€í™”
        let colorWave = sin(frameCount * 0.05 + i * 1.2) * 15;
        let alpha = 160 + progress * 40 + colorWave;
        fill(
            constrain(color[0] + colorWave * 0.5, 0, 255),
            constrain(color[1] + colorWave * 0.3, 0, 255),
            constrain(color[2] + colorWave * 0.7, 0, 255),
            alpha
        );
        
        // ìœ ê¸°ì  ë°©ìš¸ í˜•íƒœ
        drawFluidDrop(dropSize / stretchX, dropSize / stretchY, i);
        
        pop();
    }
    
    // ì¤‘ì•™ í†µí•© ë©ì–´ë¦¬ - ì•„ì´ìŠ¤í¬ë¦¼ìœ¼ë¡œ ëª¨í•‘
    if (progress > 0.3) {
        let centerProgress = map(progress, 0.3, 1, 0, 1);
        
        if (centerProgress < 0.7) {
            // ì´ˆê¸°: ì‚´ì•„ìˆëŠ” ìœ ê¸°ì²´ í˜•íƒœ
            let baseSize = lerp(25, 75, easeInOutCubic(centerProgress));
            let pulse1 = sin(frameCount * 0.06) * 0.1 + 1;
            let pulse2 = cos(frameCount * 0.04) * 0.05 + 1;
            let centerSize = baseSize * pulse1 * pulse2;
            
            fill(color[0], color[1], color[2], 200 + centerProgress * 55);
            
            beginShape();
            for (let angle = 0; angle < 360; angle += 10) {
                let radius = centerSize * 0.5;
                
                // ì ì§„ì ìœ¼ë¡œ 3ê°œ ì˜ì—­ìœ¼ë¡œ ë¶„í™”
                let morphToTriple = map(centerProgress, 0.4, 0.7, 0, 1);
                morphToTriple = constrain(morphToTriple, 0, 1);
                
                // 3ê°œ ìŠ¤ì¿± ìœ„ì¹˜ ë¯¸ë¦¬ë³´ê¸°
                let region = floor(angle / 120); // 0, 1, 2 ì˜ì—­
                let regionCenter = region * 120 + 60; // ê° ì˜ì—­ì˜ ì¤‘ì‹¬ê°
                let distFromCenter = abs(angle - regionCenter);
                if (distFromCenter > 60) distFromCenter = 120 - distFromCenter;
                
                let regionFactor = map(distFromCenter, 0, 60, 1.2, 0.8);
                radius *= lerp(1, regionFactor, morphToTriple);
                
                let wave1 = sin(radians(angle * 2) + frameCount * 0.08) * 4;
                let wave2 = cos(radians(angle * 3) + frameCount * 0.05) * 2;
                let wave3 = sin(radians(angle * 5) + frameCount * 0.12) * 1;
                
                radius += (wave1 + wave2 + wave3) * (1 - centerProgress * 0.7);
                
                let x = cos(radians(angle)) * radius;
                let y = sin(radians(angle)) * radius * 1.03;
                vertex(x, y);
            }
            endShape(CLOSE);
            
        } else {
            // í›„ê¸°: ì•„ì´ìŠ¤í¬ë¦¼ ìŠ¤ì¿±ë“¤ë¡œ ë³€í˜• (ì™„ì„± í›„ ìœ ì§€)
            let morphProgress = map(centerProgress, 0.7, 1, 0, 1);
            morphProgress = constrain(morphProgress, 0, 1); // 1ì—ì„œ ë©ˆì¶¤
            drawIceCreamTransition(color, morphProgress);
        }
        
        // ì½˜ í˜•íƒœë¡œ ë³€í˜•ë˜ëŠ” í•˜ë‹¨ë¶€ (ì™„ì„± í›„ ìœ ì§€)
        if (centerProgress > 0.6) {
            let coneProgress = map(centerProgress, 0.6, 1, 0, 1);
            coneProgress = constrain(coneProgress, 0, 1); // 1ì—ì„œ ë©ˆì¶¤
            drawConeTransition(coneProgress);
        }
    }
    
    pop();
}

function drawFluidMelt(crystal, color, progress) {
    push();
    
    let meltEase = easeInOutCubic(progress);
    
    // ì‚¼ê°í˜•ë“¤ì´ ì„œë¡œ ì—°ê²°ë˜ì–´ ë³€í˜•ë˜ëŠ” êµ¬ì¡°
    let triangles = [
        {x: -20, y: -25, size: 18, connections: [1, 2], phase: 0},
        {x: 15, y: -20, size: 22, connections: [0, 3, 4], phase: 0.2},
        {x: -10, y: 5, size: 20, connections: [0, 5], phase: 0.1},
        {x: 25, y: 10, size: 16, connections: [1, 4], phase: 0.4},
        {x: 0, y: 30, size: 24, connections: [1, 3, 5], phase: 0.3},
        {x: -30, y: 15, size: 19, connections: [2, 4], phase: 0.5}
    ];
    
    // ì—°ê²°ì„ ë“¤ì„ ë¨¼ì € ê·¸ë ¤ì„œ ìœ ê¸°ì  ê´€ê³„ í‘œí˜„
    if (progress < 0.7) {
        drawConnections(triangles, color, progress);
    }
    
    for (let i = 0; i < triangles.length; i++) {
        push();
        
        let tri = triangles[i];
        let localProgress = constrain(progress - tri.phase * 0.3, 0, 1);
        let morphFactor = easeInOutCubic(localProgress);
        
        // ë” ë³µì¡í•œ ë¬¼ë¦¬ ì‹œë®¬ë ˆì´ì…˜
        let gravity = localProgress * localProgress * 25;
        let viscosity = sin(frameCount * 0.03 + i * 1.2) * 4 * (1 - morphFactor * 0.5);
        let turbulence = cos(frameCount * 0.07 + i * 0.8) * 2 * morphFactor;
        
        // ì£¼ë³€ ì‚¼ê°í˜•ë“¤ì˜ ì˜í–¥ìœ¼ë¡œ ìœ„ì¹˜ ì¡°ì • (ìœ ê¸°ì  ìƒí˜¸ì‘ìš©)
        let influenceX = 0, influenceY = 0;
        for (let conn of tri.connections) {
            let connTri = triangles[conn];
            let distance = dist(tri.x, tri.y, connTri.x, connTri.y);
            let force = (100 - distance) * 0.02 * progress;
            let angle = atan2(connTri.y - tri.y, connTri.x - tri.x);
            influenceX += cos(angle) * force;
            influenceY += sin(angle) * force;
        }
        
        let currentX = tri.x + viscosity + turbulence + influenceX;
        let currentY = tri.y + gravity * (1 + i * 0.08) + influenceY;
        
        translate(currentX, currentY);
        rotate(sin(frameCount * 0.02 + i) * 0.1 * morphFactor);
        
        // ìƒ‰ìƒì´ ì‹œê°„ì— ë”°ë¼ ìœ ê¸°ì ìœ¼ë¡œ ë³€í™”
        let colorShift = sin(frameCount * 0.05 + i * 0.7) * 10 * morphFactor;
        let alpha = 180 + progress * 50 + sin(frameCount * 0.04 + i) * 20;
        fill(
            constrain(color[0] + colorShift, 0, 255), 
            constrain(color[1] + colorShift * 0.5, 0, 255), 
            constrain(color[2] + colorShift * 0.3, 0, 255), 
            alpha
        );
        noStroke();
        
        if (morphFactor < 0.4) {
            // ì‚¼ê°í˜•ì´ ìœ ê¸°ì ìœ¼ë¡œ ë³€í˜•
            drawOrganicTriangle(tri.size, morphFactor, i);
        } else if (morphFactor < 0.8) {
            // ì „í™˜ ë‹¨ê³„ - ë³µì¡í•œ ìœ ê¸°ì²´ í˜•íƒœ
            drawTransitionBlob(tri.size, morphFactor, i);
        } else {
            // ìµœì¢… ë°©ìš¸ í˜•íƒœ
            drawOrganicDrop(tri.size, morphFactor, i, progress);
        }
        
        pop();
    }
    
    pop();
}

function drawConnections(triangles, color, progress) {
    if (progress > 0.6) return;
    
    stroke(color[0], color[1], color[2], 80 * (1 - progress * 1.5));
    strokeWeight(2 * (1 - progress));
    
    for (let i = 0; i < triangles.length; i++) {
        let tri = triangles[i];
        for (let connIndex of tri.connections) {
            if (connIndex > i) { // ì¤‘ë³µ ì—°ê²° ë°©ì§€
                let connTri = triangles[connIndex];
                
                // ë² ì§€ì–´ ê³¡ì„ ìœ¼ë¡œ ìœ ê¸°ì ì¸ ì—°ê²°ì„ 
                let midX = (tri.x + connTri.x) / 2;
                let midY = (tri.y + connTri.y) / 2;
                let controlOffset = sin(frameCount * 0.03 + i + connIndex) * 15;
                
                bezier(
                    tri.x, tri.y,
                    midX + controlOffset, midY - abs(controlOffset) * 0.5,
                    midX - controlOffset, midY + abs(controlOffset) * 0.5,
                    connTri.x, connTri.y
                );
            }
        }
    }
    noStroke();
}

function drawOrganicTriangle(size, morphFactor, index) {
    let vertices = 3;
    let baseRadius = size;
    
    beginShape();
    for (let j = 0; j < vertices; j++) {
        let angle = j * 120 - 90;
        
        // ê° ê¼­ì§“ì ì´ ë…ë¦½ì ìœ¼ë¡œ ë³€í˜•
        let radiusVariation = sin(frameCount * 0.04 + j * 2 + index) * 3 * morphFactor;
        let radius = baseRadius + radiusVariation;
        
        // ëª¨ì„œë¦¬ê°€ ì ì§„ì ìœ¼ë¡œ ë‘¥ê¸€ì–´ì§
        let roundness = morphFactor * 1.5;
        radius *= (1 + roundness * 0.2);
        
        let x = cos(radians(angle)) * radius;
        let y = sin(radians(angle)) * radius;
        
        if (morphFactor > 0.1) {
            // ë² ì§€ì–´ë¡œ ìœ ê¸°ì  ê³¡ì„  ìƒì„±
            let nextJ = (j + 1) % vertices;
            let nextAngle = nextJ * 120 - 90;
            let nextRadius = baseRadius + sin(frameCount * 0.04 + nextJ * 2 + index) * 3 * morphFactor;
            nextRadius *= (1 + roundness * 0.2);
            
            let nextX = cos(radians(nextAngle)) * nextRadius;
            let nextY = sin(radians(nextAngle)) * nextRadius;
            
            let controlDistance = radius * (0.5 + roundness * 0.3);
            let controlAngle = angle + 60;
            let controlX = cos(radians(controlAngle)) * controlDistance;
            let controlY = sin(radians(controlAngle)) * controlDistance;
            
            if (j === 0) vertex(x, y);
            quadraticVertex(controlX, controlY, nextX, nextY);
        } else {
            vertex(x, y);
        }
    }
    endShape(CLOSE);
}

function drawTransitionBlob(size, morphFactor, index) {
    // ë³µì¡í•œ ìœ ê¸°ì²´ ì¤‘ê°„ í˜•íƒœ
    let points = 12;
    let baseRadius = size * 0.8;
    
    beginShape();
    for (let i = 0; i < points; i++) {
        let angle = i * (360 / points);
        
        // ì—¬ëŸ¬ ì£¼íŒŒìˆ˜ì˜ íŒŒë™ì´ ê²°í•©ëœ ë³µì¡í•œ í˜•íƒœ
        let wave1 = sin(radians(angle * 3) + frameCount * 0.05 + index) * 4;
        let wave2 = cos(radians(angle * 5) + frameCount * 0.03 + index * 1.5) * 2;
        let wave3 = sin(radians(angle * 2) + frameCount * 0.07 + index * 0.7) * 3;
        
        let radius = baseRadius + wave1 + wave2 + wave3;
        radius *= (1 + morphFactor * 0.3);
        
        let x = cos(radians(angle)) * radius;
        let y = sin(radians(angle)) * radius;
        vertex(x, y);
    }
    endShape(CLOSE);
}

function drawOrganicDrop(size, morphFactor, index, globalProgress) {
    let dropSize = size * (0.9 + morphFactor * 0.3);
    
    // ë¬¼ë°©ìš¸ì´ ì‚´ì•„ìˆëŠ” ê²ƒì²˜ëŸ¼ ì›€ì§ì„
    let pulseSize = sin(frameCount * 0.06 + index * 1.3) * 0.05 + 1;
    let asymmetry = cos(frameCount * 0.04 + index * 0.9) * 0.1;
    
    beginShape();
    for (let angle = 0; angle < 360; angle += 8) {
        let radius = dropSize * 0.5 * pulseSize;
        
        // ë¬¼ë°©ìš¸ì˜ ìì—°ìŠ¤ëŸ¬ìš´ í˜•íƒœ
        if (angle > 150 && angle < 210) {
            radius *= 1.15; // ì•„ë˜ìª½ ë³¼ë¡
        } else if (angle > 30 && angle < 150) {
            radius *= 0.95; // ì˜†ë©´ ì•½ê°„ ë“¤ì–´ê°
        }
        
        // ë¯¸ì„¸í•œ í‘œë©´ ë–¨ë¦¼
        let surfaceTension = sin(angle * 4 + frameCount * 0.1 + index) * 0.02;
        radius *= (1 + surfaceTension);
        
        let x = cos(radians(angle)) * radius * (1 + asymmetry);
        let y = sin(radians(angle)) * radius * (1.05 - asymmetry * 0.5);
        vertex(x, y);
    }
    endShape(CLOSE);
    
    // ë™ì  í•˜ì´ë¼ì´íŠ¸
    if (globalProgress > 0.3) {
        let highlightIntensity = sin(frameCount * 0.08 + index) * 30 + 70;
        fill(
            Math.min(255, color[0] + highlightIntensity), 
            Math.min(255, color[1] + highlightIntensity), 
            Math.min(255, color[2] + highlightIntensity), 
            120
        );
        
        let highlightSize = dropSize * (0.25 + sin(frameCount * 0.05 + index) * 0.05);
        let offsetX = -dropSize * 0.15 + cos(frameCount * 0.03 + index) * 2;
        let offsetY = -dropSize * 0.2 + sin(frameCount * 0.04 + index) * 1;
        
        ellipse(offsetX, offsetY, highlightSize, highlightSize);
    }
}

function drawSurfaceTension(crystal, color, progress) {
    push();
    
    let tensionEase = easeInOutQuart(progress);
    
    // ë°©ìš¸ë“¤ì´ ì„œë¡œ ëŒì–´ë‹¹ê¸°ë©° í•©ì³ì§€ëŠ” ë³µì¡í•œ ì‹œìŠ¤í…œ
    let drops = [
        {angle: 0, distance: 35, size: 16, phase: 0},
        {angle: 45, distance: 32, size: 18, phase: 0.1},
        {angle: 90, distance: 38, size: 14, phase: 0.2},
        {angle: 135, distance: 30, size: 20, phase: 0.05},
        {angle: 180, distance: 33, size: 17, phase: 0.15},
        {angle: 225, distance: 36, size: 15, phase: 0.25},
        {angle: 270, distance: 31, size: 19, phase: 0.08},
        {angle: 315, distance: 34, size: 16, phase: 0.18}
    ];
    
    // ì¤‘ì‹¬ìœ¼ë¡œì˜ ì¸ë ¥ ê³„ì‚°
    let centralMass = progress * 100;
    
    for (let i = 0; i < drops.length; i++) {
        push();
        
        let drop = drops[i];
        let localProgress = constrain(progress - drop.phase, 0, 1);
        let attraction = easeInOutCubic(localProgress);
        
        // ë³µì¡í•œ ê¶¤ë„ ìš´ë™
        let spiralFactor = sin(frameCount * 0.04 + i * 0.8) * 5 * (1 - attraction);
        let currentDistance = lerp(drop.distance, 8, attraction);
        currentDistance += spiralFactor;
        
        let currentAngle = drop.angle + sin(frameCount * 0.02 + i) * 10 * (1 - attraction);
        
        let x = cos(radians(currentAngle)) * currentDistance;
        let y = sin(radians(currentAngle)) * currentDistance + 15;
        
        translate(x, y);
        
        // ë°©ìš¸ ê°„ ìƒí˜¸ì‘ìš©ìœ¼ë¡œ í¬ê¸° ë³€í™”
        let neighborInfluence = 0;
        for (let j = 0; j < drops.length; j++) {
            if (i !== j) {
                let otherDrop = drops[j];
                let otherX = cos(radians(otherDrop.angle)) * lerp(otherDrop.distance, 8, attraction);
                let otherY = sin(radians(otherDrop.angle)) * lerp(otherDrop.distance, 8, attraction) + 15;
                let distance = dist(x, y, otherX, otherY);
                
                if (distance < 20) {
                    neighborInfluence += (20 - distance) * 0.01;
                }
            }
        }
        
        let dropSize = drop.size * (1 - attraction * 0.4) * (1 + neighborInfluence);
        
        // í•©ì³ì§€ëŠ” ê³¼ì •ì—ì„œì˜ ë³€í˜•
        let stretchToCenter = attraction * 0.6;
        let centerAngle = atan2(-y, -x);
        let stretchX = 1 - stretchToCenter * 0.5;
        let stretchY = 1 + stretchToCenter * 0.8;
        
        rotate(centerAngle * stretchToCenter);
        scale(stretchX, stretchY);
        
        // ë™ì  ìƒ‰ìƒ ë³€í™”
        let colorWave = sin(frameCount * 0.05 + i * 1.2) * 15;
        let alpha = 160 + progress * 40 + colorWave;
        fill(
            constrain(color[0] + colorWave * 0.5, 0, 255),
            constrain(color[1] + colorWave * 0.3, 0, 255),
            constrain(color[2] + colorWave * 0.7, 0, 255),
            alpha
        );
        
        // ìœ ê¸°ì  ë°©ìš¸ í˜•íƒœ
        drawFluidDrop(dropSize / stretchX, dropSize / stretchY, i);
        
        pop();
    }
    
    // ì¤‘ì•™ í†µí•© ë©ì–´ë¦¬ - ì•„ì´ìŠ¤í¬ë¦¼ìœ¼ë¡œ ëª¨í•‘
    if (progress > 0.3) {
        let centerProgress = map(progress, 0.3, 1, 0, 1);
        
        if (centerProgress < 0.7) {
            // ì´ˆê¸°: ì‚´ì•„ìˆëŠ” ìœ ê¸°ì²´ í˜•íƒœ
            let baseSize = lerp(25, 75, easeInOutCubic(centerProgress));
            let pulse1 = sin(frameCount * 0.06) * 0.1 + 1;
            let pulse2 = cos(frameCount * 0.04) * 0.05 + 1;
            let centerSize = baseSize * pulse1 * pulse2;
            
            fill(color[0], color[1], color[2], 200 + centerProgress * 55);
            
            beginShape();
            for (let angle = 0; angle < 360; angle += 10) {
                let radius = centerSize * 0.5;
                
                // ì ì§„ì ìœ¼ë¡œ 3ê°œ ì˜ì—­ìœ¼ë¡œ ë¶„í™”
                let morphToTriple = map(centerProgress, 0.4, 0.7, 0, 1);
                morphToTriple = constrain(morphToTriple, 0, 1);
                
                // 3ê°œ ìŠ¤ì¿± ìœ„ì¹˜ ë¯¸ë¦¬ë³´ê¸°
                let region = floor(angle / 120); // 0, 1, 2 ì˜ì—­
                let regionCenter = region * 120 + 60; // ê° ì˜ì—­ì˜ ì¤‘ì‹¬ê°
                let distFromCenter = abs(angle - regionCenter);
                if (distFromCenter > 60) distFromCenter = 120 - distFromCenter;
                
                let regionFactor = map(distFromCenter, 0, 60, 1.2, 0.8);
                radius *= lerp(1, regionFactor, morphToTriple);
                
                let wave1 = sin(radians(angle * 2) + frameCount * 0.08) * 4;
                let wave2 = cos(radians(angle * 3) + frameCount * 0.05) * 2;
                let wave3 = sin(radians(angle * 5) + frameCount * 0.12) * 1;
                
                radius += (wave1 + wave2 + wave3) * (1 - centerProgress * 0.7);
                
                let x = cos(radians(angle)) * radius;
                let y = sin(radians(angle)) * radius * 1.03;
                vertex(x, y);
            }
            endShape(CLOSE);
            
        } else {
            // í›„ê¸°: ì•„ì´ìŠ¤í¬ë¦¼ ìŠ¤ì¿±ë“¤ë¡œ ë³€í˜• (ì™„ì„± í›„ ìœ ì§€)
            let morphProgress = map(centerProgress, 0.7, 1, 0, 1);
            morphProgress = constrain(morphProgress, 0, 1); // 1ì—ì„œ ë©ˆì¶¤
            drawIceCreamTransition(color, morphProgress);
        }
        
        // ì½˜ í˜•íƒœë¡œ ë³€í˜•ë˜ëŠ” í•˜ë‹¨ë¶€ (ì™„ì„± í›„ ìœ ì§€)
        if (centerProgress > 0.6) {
            let coneProgress = map(centerProgress, 0.6, 1, 0, 1);
            coneProgress = constrain(coneProgress, 0, 1); // 1ì—ì„œ ë©ˆì¶¤
            drawConeTransition(coneProgress, color);
        }
    }
    
    pop();
}

function drawFluidDrop(width, height, index) {
    let points = 16;
    
    beginShape();
    for (let i = 0; i < points; i++) {
        let angle = i * (360 / points);
        let baseRadius = min(width, height) * 0.5;
        
        // ë°©ìš¸ì˜ ìì—°ìŠ¤ëŸ¬ìš´ ë¹„ëŒ€ì¹­
        let radiusX = width * 0.5;
        let radiusY = height * 0.5;
        
        // í‘œë©´ì¥ë ¥ íš¨ê³¼
        let tension = sin(angle * 4 + frameCount * 0.1 + index) * 0.03 + 1;
        
        let x = cos(radians(angle)) * radiusX * tension;
        let y = sin(radians(angle)) * radiusY * tension;
        
        vertex(x, y);
    }
    endShape(CLOSE);
}

function drawIceCreamTransition(color, morphProgress) {
    let scale = 0.8;
    let scoopRadius = 22 * scale;
    let scoopY = -40 * scale;
    
    // 3ê°œ ìŠ¤ì¿±ì˜ ìœ„ì¹˜ì™€ ìƒ‰ìƒ ì •ì˜
    let scoops = [
        {x: -15 * scale, y: scoopY, color: [77, 255, 168], delay: 0},      // Forest Green (ì™¼ìª½)
        {x: 15 * scale, y: scoopY, color: [100, 149, 237], delay: 0.2},    // Cornflower Blue (ì˜¤ë¥¸ìª½)
        {x: 0, y: scoopY - 10 * scale, color: [255, 255, 0], delay: 0.4}   // Yellow (ìœ„ìª½)
    ];
    
    for (let i = 0; i < scoops.length; i++) {
        let scoop = scoops[i];
        let localProgress = constrain((morphProgress - scoop.delay) / 0.6, 0, 1);
        
        if (localProgress > 0) {
            push();
            translate(scoop.x, scoop.y);
            
            // ì›ë˜ ìƒ‰ìƒì—ì„œ ìŠ¤ì¿± ìƒ‰ìƒìœ¼ë¡œ ë³€í™”
            let r = lerp(color[0], scoop.color[0], localProgress);
            let g = lerp(color[1], scoop.color[1], localProgress);
            let b = lerp(color[2], scoop.color[2], localProgress);
            
            fill(r, g, b, 200 + localProgress * 55);
            noStroke();
            
            // ìœ ê¸°ì  í˜•íƒœì—ì„œ ì˜¤ê¸€ì˜¤ê¸€í•œ ìŠ¤ì¿±ìœ¼ë¡œ ë³€í˜•
            beginShape();
            for (let angle = 0; angle < 360; angle += 15) {
                let radius = scoopRadius;
                
                if (localProgress < 0.5) {
                    // ì´ˆê¸°: ë¶€ë“œëŸ¬ìš´ ìœ ê¸°ì²´ í˜•íƒœ
                    let wave = sin(radians(angle * 2) + frameCount * 0.05 + i) * 3;
                    radius += wave * (1 - localProgress * 2);
                } else {
                    // í›„ê¸°: ì˜¤ê¸€ì˜¤ê¸€í•œ ì•„ì´ìŠ¤í¬ë¦¼ ì§ˆê°
                    let noiseValue = noise(
                        cos(radians(angle)) * 0.8 + i * 10, 
                        sin(radians(angle)) * 0.8 + i * 10, 
                        frameCount * 0.01
                    );
                    radius += (noiseValue - 0.5) * 8 * scale * ((localProgress - 0.5) * 2);
                }
                
                let x = cos(radians(angle)) * radius;
                let y = sin(radians(angle)) * radius;
                vertex(x, y);
            }
            endShape(CLOSE);
            
            pop();
        }
    }
}

function drawConeTransition(coneProgress, color) {
    if (coneProgress > 0) {
        let scale = 0.8;
        
        // ì›ë˜ ì¤‘ì•™ ë©ì–´ë¦¬ì—ì„œ ì½˜ í˜•íƒœë¡œ ë³€í˜•
        let alpha = coneProgress >= 1 ? 255 : 255 * easeInOutCubic(coneProgress);
        
        // ì—°í•œ ë…¸ë€ìƒ‰ìœ¼ë¡œ ìƒ‰ìƒ ë³€í™”
        let r = lerp(color[0], 255, coneProgress);
        let g = lerp(color[1], 255, coneProgress);
        let b = lerp(color[2], 160, coneProgress);
        
        fill(r, g, b, alpha);
        noStroke();
        
        // ì›í˜•ì—ì„œ ì‚¼ê°í˜•ìœ¼ë¡œ ë³€í˜•
        if (coneProgress < 0.5) {
            // ì´ˆê¸°: ì›í˜•ì´ ì•„ë˜ë¡œ ëŠ˜ì–´ë‚¨
            let stretchProgress = coneProgress * 2;
            
            beginShape();
            for (let angle = 0; angle < 360; angle += 10) {
                let radius = 30 * scale;
                
                // ì•„ë˜ìª½ì´ ì ì  ë¾°ì¡±í•´ì§
                if (angle > 135 && angle < 225) {
                    let pointedness = map(sin(radians(angle - 180)), -1, 1, 0.3, 1);
                    radius *= lerp(1, pointedness, stretchProgress);
                }
                
                let x = cos(radians(angle)) * radius;
                let y = sin(radians(angle)) * radius * (1 + stretchProgress * 0.8);
                
                // ì•„ë˜ìª½ì„ ë” ëŠ˜ë¦¼
                if (y > 0) {
                    y *= (1 + stretchProgress * 1.5);
                }
                
                vertex(x, y);
            }
            endShape(CLOSE);
        } else {
            // í›„ê¸°: ì™„ì „í•œ ì‚¼ê°í˜• ì½˜ (ì™„ì„± í›„ì—ë„ ìœ ì§€)
            beginShape();
            vertex(0, 60 * scale);                    // ìƒë‹¨ ê¼­ì§“ì 
            vertex(-25 * scale, -20 * scale);         // ì™¼ìª½ í•˜ë‹¨
            vertex(25 * scale, -20 * scale);          // ì˜¤ë¥¸ìª½ í•˜ë‹¨
            endShape(CLOSE);
        }
    }
}
        // ê¸°ì¡´ í•¨ìˆ˜ë“¤ ìœ ì§€ (drawOriginalSVG, drawLemonIceCream, drawStrawberryIceCream, drawBlueberryIceCream ë“±)
        function drawOriginalSVG(index, crystal, color, alpha) {
            fill(color[0], color[1], color[2], alpha * 0.8);
            stroke(color[0], color[1], color[2], alpha * 0.9);
            strokeWeight(0);
            
            if (index === 0) {
                drawAccurateGroup1(crystal, alpha);
            } else if (index === 1) {
                drawAccurateGroup2(crystal, alpha);
            } else {
                drawAccurateGroup3(crystal, alpha);
            }
        }

        // ì •í™•í•œ SVG ê·¸ë£¹ë“¤ - ì›ë³¸ ì™„ì „ ì¬í˜„
        function drawAccurateGroup1(crystal, alpha) {
            let scale = 0.35;
            let centerX = crystal.svgCenterX;
            let centerY = crystal.svgCenterY;
            
            // ë©”ì¸ ì§ì‚¬ê°í˜•ë“¤ (rounded rectangles)
            drawSVGRoundedRect(230.82, 367.25, 44.82, 73.76, 21.55, centerX, centerY, scale);
            drawSVGRoundedRect(256.06, 419.5, 73.76, 44.82, 21.55, centerX, centerY, scale);
            drawSVGRoundedRect(181.07, 419.5, 73.76, 44.82, 21.55, centerX, centerY, scale);
            drawSVGRoundedRect(234.14, 441.9, 44.82, 73.76, 21.55, centerX, centerY, scale);
            
            // íšŒì „ëœ ì§ì‚¬ê°í˜•ë“¤
            push();
            translate(svgToP5X(246.86 + 36.88, centerX, scale), svgToP5Y(393.25 + 22.41, centerY, scale));
            rotate(radians(-45));
            rect(-36.88 * scale, -22.41 * scale, 73.76 * scale, 44.82 * scale, 21.55 * scale);
            pop();
            
            push();
            translate(svgToP5X(191.83 + 36.88, centerX, scale), svgToP5Y(448.27 + 22.41, centerY, scale));
            rotate(radians(-45));
            rect(-36.88 * scale, -22.41 * scale, 73.76 * scale, 44.82 * scale, 21.55 * scale);
            pop();
            
            push();
            translate(svgToP5X(259.73 + 22.41, centerX, scale), svgToP5Y(432.09 + 36.88, centerY, scale));
            rotate(radians(-45));
            rect(-22.41 * scale, -36.88 * scale, 44.82 * scale, 73.76 * scale, 21.55 * scale);
            pop();
            
            push();
            translate(svgToP5X(202.07 + 22.41, centerX, scale), svgToP5Y(381.73 + 36.88, centerY, scale));
            rotate(radians(-45));
            rect(-22.41 * scale, -36.88 * scale, 44.82 * scale, 73.76 * scale, 21.55 * scale);
            pop();
            
            // ì‘ì€ íŒ¨ìŠ¤ë“¤
            drawSVGPath1([[336.29,363.41], [318.06,368.62], [313.61,385.03], [314.54,384.66], [330.36,381.49], [336.26,363.43]], centerX, centerY, scale);
            drawSVGPath1([[178.12,524.58], [195.18,516.33], [196.74,499.4], [195.9,499.92], [180.84,505.76], [178.11,524.58]], centerX, centerY, scale);
            drawSVGPath1([[140.55,449.63], [158.17,456.58], [171.67,446.25], [170.72,445.99], [156.22,438.89], [140.55,449.61]], centerX, centerY, scale);
            drawSVGPath1([[169.52,364.06], [176.29,381.75], [193.03,384.75], [192.57,383.86], [188.03,368.36], [169.52,364.06]], centerX, centerY, scale);
            drawSVGPath1([[250.44,328.68], [242.21,345.74], [251.5,359.96], [251.85,359.02], [260.01,345.08], [250.44,328.68]], centerX, centerY, scale);
            drawSVGPath1([[259.52,552.38], [266.94,534.95], [256.99,521.17], [256.68,522.12], [249.17,536.42], [259.52,552.38]], centerX, centerY, scale);
            drawSVGPath1([[331.51,527.16], [327.34,508.67], [311.21,503.31], [311.54,504.26], [313.82,520.24], [331.51,527.16]], centerX, centerY, scale);
            drawSVGPath1([[368.11,442.2], [351.03,434], [336.81,443.33], [337.75,443.66], [351.71,451.8], [368.11,442.2]], centerX, centerY, scale);
        }

        function drawAccurateGroup2(crystal, alpha) {
            let scale = 0.28;
            let centerX = crystal.svgCenterX;
            let centerY = crystal.svgCenterY;
            
            // ë©”ì¸ í´ë¦¬ê³¤ë“¤
            drawSVGPolygon([[615.41, 443.44], [633.42, 407.41], [680.17, 377.76], [650.99, 424.74]], centerX, centerY, scale);
            drawSVGPolygon([[609.03, 431.36], [603.1, 443.44], [590.77, 449.82], [603.55, 455.28], [609.03, 466.49], [614.83, 455.28], [627.05, 449.84], [615.41, 443.44]], centerX, centerY, scale);
            drawSVGPolygon([[592.31, 337.14], [609.03, 431.63], [625.48, 337.14], [608.9, 394.13]], centerX, centerY, scale);
            drawSVGPolygon([[603.19, 443.44], [567.36, 425], [538.27, 377.9], [584.91, 407.64]], centerX, centerY, scale);
            drawSVGPolygon([[603.19, 455.28], [584.8, 491.13], [537.73, 520.27], [567.41, 473.61]], centerX, centerY, scale);
            drawSVGPolygon([[614.54, 454.92], [650.32, 473.47], [679.28, 520.62], [632.73, 490.77]], centerX, centerY, scale);
            drawSVGPolygon([[720.84, 433.54], [626.29, 449.82], [720.68, 466.74], [663.79, 449.86]], centerX, centerY, scale);
            drawSVGPolygon([[625.8, 559.28], [609.08, 464.82], [592.6, 559.28], [609.19, 502.3]], centerX, centerY, scale);
            drawSVGPolygon([[496.98, 466.49], [591.44, 449.77], [496.98, 433.32], [553.94, 449.91]], centerX, centerY, scale);
            
            // ì‘ì€ ë””í…Œì¼ë“¤ - ì›í˜• ë°”ë¡œ ê·¼ì²˜ì— ë°°ì¹˜
            // ìƒë‹¨ ì¢Œìš° ìŒ (ì›í˜• ë°”ë¡œ ë°‘)
            drawSVGPolygon([[627.38, 376.34], [625.82, 387.68], [632.84, 378.28], [633.71, 368.18]], centerX, centerY, scale);
            drawSVGPolygon([[585.44, 378.36], [591.86, 387.84], [590.77, 376.13], [584.66, 368.06]], centerX, centerY, scale);
            // í•˜ë‹¨ ì¢Œìš° ìŒ (ì›í˜• ë°”ë¡œ ìœ„)
            drawSVGPolygon([[590.62, 521.66], [592.18, 510.32], [585.16, 519.72], [584.29, 529.82]], centerX, centerY, scale);
            drawSVGPolygon([[632.56, 519.64], [626.14, 510.16], [627.23, 521.87], [633.34, 529.94]], centerX, centerY, scale);
            
            // ìƒí•˜ ìŒ (ê¸°ì¡´)
            drawSVGPolygon([[608.83, 313.22], [604.39, 335.27], [608.83, 355.36], [613.53, 334.91]], centerX, centerY, scale);
            drawSVGPolygon([[609.23, 584.43], [613.67, 562.36], [609.23, 542.27], [604.55, 562.74]], centerX, centerY, scale);
            
            // ì¢Œìš° ê¸°ì¡´ (ê·¸ëŒ€ë¡œ ìœ ì§€)
            drawSVGPolygon([[473.55, 450], [495.62, 454.43], [515.71, 450], [495.24, 445.31]], centerX, centerY, scale);
            drawSVGPolygon([[745.94, 449.8], [723.89, 445.36], [703.8, 449.8], [724.25, 454.48]], centerX, centerY, scale);
            
            // ì¢Œì¸¡ ì›í˜•ë“¤ ë°”ë¡œ ì˜†ì— ë””í…Œì¼ ìŒ ì¶”ê°€ (ì„œë¡œë¥¼ í–¥í•˜ëŠ” ê°ë„)
            drawSVGPolygon([[540.34, 427.38], [529.68, 425.82], [538.28, 432.84], [548.18, 433.71]], centerX, centerY, scale);
            drawSVGPolygon([[540.66, 470.62], [529.82, 472.18], [539.72, 465.16], [551.32, 464.29]], centerX, centerY, scale);
            
            // ìš°ì¸¡ ì›í˜•ë“¤ ë°”ë¡œ ì˜†ì— ë””í…Œì¼ ìŒ ì¶”ê°€ (ì¢Œì¸¡ê³¼ ì„œë¡œë¥¼ í–¥í•˜ëŠ” ëŒ€ì¹­)
            drawSVGPolygon([[677.66, 470.62], [688.32, 472.18], [679.72, 465.16], [669.82, 464.29]], centerX, centerY, scale);
            drawSVGPolygon([[677.34, 427.38], [688.18, 425.82], [678.28, 432.84], [666.68, 433.71]], centerX, centerY, scale);
            
            // ì›í˜•ë“¤
            fill(crystal.color[0], crystal.color[1], crystal.color[2], alpha * 0.9);
            ellipse(svgToP5X(583.06, centerX, scale), svgToP5Y(362.76, centerY, scale), 2.56 * 2 * scale, 2.56 * 2 * scale);
            ellipse(svgToP5X(634.89, centerX, scale), svgToP5Y(362.76, centerY, scale), 2.56 * 2 * scale, 2.56 * 2 * scale);
            ellipse(svgToP5X(633.09, centerX, scale), svgToP5Y(535.99, centerY, scale), 2.56 * 2 * scale, 2.56 * 2 * scale);
            ellipse(svgToP5X(581.9, centerX, scale), svgToP5Y(536.39, centerY, scale), 2.56 * 2 * scale, 2.56 * 2 * scale);
            ellipse(svgToP5X(522.46, centerX, scale), svgToP5Y(476.42, centerY, scale), 2.56 * 2 * scale, 2.56 * 2 * scale);
            ellipse(svgToP5X(522.46, centerX, scale), svgToP5Y(423.47, centerY, scale), 2.56 * 2 * scale, 2.56 * 2 * scale);
            ellipse(svgToP5X(695.6, centerX, scale), svgToP5Y(423.47, centerY, scale), 2.56 * 2 * scale, 2.56 * 2 * scale);
            ellipse(svgToP5X(695.24, centerX, scale), svgToP5Y(476.82, centerY, scale), 2.56 * 2 * scale, 2.56 * 2 * scale);
            
            // ì§ì‚¬ê°í˜•ë“¤
            fill(crystal.color[0], crystal.color[1], crystal.color[2], alpha * 0.8);
            rect(svgToP5X(512.96, centerX, scale), svgToP5Y(449.57, centerY, scale), 43.03 * scale, 0.62 * scale);
            rect(svgToP5X(608.88, centerX, scale), svgToP5Y(502.01, centerY, scale), 0.62 * scale, 43.03 * scale);
        }

        function drawAccurateGroup3(crystal, alpha) {
            let scale = 0.25;
            let centerX = crystal.svgCenterX;
            let centerY = crystal.svgCenterY;
            
            // ë©”ì¸ í´ë¦¬ê³¤ë“¤ - opacity 0.3ê³¼ 0.5 êµ¬ë¶„
            fill(crystal.color[0], crystal.color[1], crystal.color[2], alpha * 0.5); // cls-3 (opacity .5)
            drawSVGPolygon([[882.67, 463.31], [922.58, 449.32], [884.08, 434.53], [857.52, 448.46]], centerX, centerY, scale);
            drawSVGPolygon([[964.09, 510.95], [949.06, 471.41], [935.26, 510.29], [949.88, 536.49]], centerX, centerY, scale);
            drawSVGPolygon([[1015.84, 434.97], [975.74, 448.43], [1014.04, 463.76], [1040.79, 450.18]], centerX, centerY, scale);
            drawSVGPolygon([[934.18, 381.99], [948.59, 421.75], [963, 383.09], [948.79, 356.67]], centerX, centerY, scale);
            
            // ì‘ì€ íŒ¨ìŠ¤ë“¤
            drawSVGPath1([[864.92, 358.17], [867.82, 370.35], [878.53, 373.77], [878.31, 373.15], [876.69, 362.6], [864.94, 358.17]], centerX, centerY, scale);
            drawSVGPath1([[1033.06, 534.45], [1029.47, 522.45], [1018.59, 519.65], [1018.84, 520.25], [1021.06, 530.7], [1033.06, 534.45]], centerX, centerY, scale);
            drawSVGPath1([[873.14, 540.87], [883.63, 534.01], [883.21, 522.79], [882.71, 523.19], [873.34, 528.3], [873.14, 540.87]], centerX, centerY, scale);
            drawSVGPath1([[1033.61, 362.32], [1021.5, 365.5], [1018.33, 376.28], [1018.94, 376.05], [1029.45, 374.19], [1033.61, 362.32]], centerX, centerY, scale);
            
            fill(crystal.color[0], crystal.color[1], crystal.color[2], alpha * 0.3); // cls-2 (opacity .3)
            drawSVGPolygon([[906.67, 462.74], [883.81, 519.94], [936.92, 491.87], [947.07, 449.37]], centerX, centerY, scale);
            drawSVGPolygon([[960.7, 490.48], [1016.48, 516.61], [991.51, 461.95], [949.68, 449.37]], centerX, centerY, scale);
            drawSVGPolygon([[937.05, 406.46], [881.91, 378.99], [905.55, 434.23], [947.07, 447.83]], centerX, centerY, scale);
            drawSVGPolygon([[989.69, 436.46], [1014.98, 380.29], [960.71, 406.07], [948.76, 448.1]], centerX, centerY, scale);
        }

        function drawLemonIceCream(progress) {
            push();
            
            // ìŠ¤ì¼€ì¼ê³¼ ì¤‘ì‹¬ì  ì¡°ì •
            let scale = 0.25;
            let offsetX = -595.27 * scale;
            let offsetY = -380 * scale;
            
            // 1. ì´ˆë¡ìƒ‰ ìŠ¤í‹± (ìœ„ì•„ë˜ë¡œ ê¸¸ê²Œ) - #4dffa8, opacity 0.8
            if (progress > 0.1) {
                let stickProgress = map(progress, 0.1, 0.4, 0, 1);
                fill(77, 255, 168, 255 * 0.8 * stickProgress);
                noStroke();
                
                // ìŠ¤í‹±ì˜ ì‹¤ì œ í¬ê¸°ì™€ ìœ„ì¹˜
                let stickX = offsetX + 541.74 * scale;
                let stickY = offsetY + 199.38 * scale;
                let stickW = 33.23 * scale;
                let stickH = 465.17 * scale;
                let stickR = 16.61 * scale;
                
                rect(stickX, stickY, stickW, stickH, stickR);
            }
            
            // 2. ë©”ì¸ ì•„ì´ìŠ¤í¬ë¦¼ - ìœ„ìª½ ë² ì–´ë¬¸ + ìì—°ìŠ¤ëŸ¬ìš´ ê·¸ë¼ë°ì´ì…˜
            if (progress > 0.3) {
                let iceProgress = map(progress, 0.3, 0.8, 0, 1);
                
                // ì•„ì´ìŠ¤í¬ë¦¼ í¬ê¸° ì¡°ì • (ì„¸ë¡œë¡œ ë” ê¸¸ê²Œ, ì¤‘ì•™ ì •ë ¬)
                let stickCenterX = offsetX + (541.74 + 33.23/2) * scale; // ìŠ¤í‹± ì¤‘ì‹¬
                let iceW = 200 * scale; // ë„ˆë¹„ (ì´ë¯¸ì§€ì— ë§ê²Œ ì¡°ì •)
                let iceH = 350 * scale; // ë†’ì´ (ë” ê¸¸ê²Œ)
                let iceX = stickCenterX - iceW/2; // ì¤‘ì•™ ì •ë ¬
                let iceY = offsetY + 195 * scale;
                
                // ìœ„ìª½ ë² ì–´ë¬¸ ë¶€ë¶„ë“¤ (ì´ë¯¸ì§€ì²˜ëŸ¼ ìœ„ìª½ì—ë§Œ)
                let topBites = [
                    {x: iceW * 0.15, y: iceH * 0.05, radius: 35 * scale, depth: 0.8},
                    {x: iceW * 0.85, y: iceH * 0.08, radius: 30 * scale, depth: 0.35},
                    {x: iceW * 0.45, y: iceH * 0.02, radius: 25 * scale, depth: 0.3}
                ];
                
                // ë” ìì—°ìŠ¤ëŸ¬ìš´ ê·¸ë¼ë°ì´ì…˜ì„ ìœ„í•´ ì„¸ë°€í•˜ê²Œ ë Œë”ë§
                for (let y = 0; y < iceH; y += 1) {
                    let gradientProgress = y / iceH;
                    
                    // ë” ë¶€ë“œëŸ¬ìš´ ê³¡ì„  ê·¸ë¼ë°ì´ì…˜ (ì´ë¯¸ì§€ì™€ ìœ ì‚¬í•˜ê²Œ)
                    let smoothProgress = (sin((gradientProgress - 0.5) * PI) + 1) / 2;
                    smoothProgress = pow(smoothProgress, 1.2); // ë” ìì—°ìŠ¤ëŸ¬ìš´ ì»¤ë¸Œ
                    
                    // ìœ„ìª½(ê±°ì˜ íˆ¬ëª…í•œ í°ìƒ‰)ì—ì„œ ì•„ë˜ìª½(ì§„í•œ íŒŒë€ìƒ‰)ìœ¼ë¡œ
                    let topColor = [255, 255, 255, 0.20]; // ë” ë¶ˆíˆ¬ëª…í•˜ê²Œ
                    let bottomColor = [40, 110, 200, 0.9]; // ë” ì§„í•˜ê³  ë¶ˆíˆ¬ëª…í•œ íŒŒë€ìƒ‰
                    
                    let r = lerp(topColor[0], bottomColor[0], smoothProgress);
                    let g = lerp(topColor[1], bottomColor[1], smoothProgress);
                    let b = lerp(topColor[2], bottomColor[2], smoothProgress);
                    let a = lerp(topColor[3], bottomColor[3], smoothProgress);
                    
                    // ë…¸ì´ì¦ˆ íš¨ê³¼ (ë” ë¯¸ì„¸í•˜ê²Œ)
                    let noiseValue = noise(iceX * 0.008, (iceY + y) * 0.008, frameCount * 0.015);
                    let noiseIntensity = 0.06;
                    
                    r += (noiseValue - 0.5) * 15 * noiseIntensity;
                    g += (noiseValue - 0.5) * 15 * noiseIntensity;
                    b += (noiseValue - 0.5) * 15 * noiseIntensity;
                    a *= (1 + (noiseValue - 0.5) * noiseIntensity * 0.3);
                    
                    r = constrain(r, 0, 255);
                    g = constrain(g, 0, 255);
                    b = constrain(b, 0, 255);
                    a = constrain(a, 0.2, 1);
                    
                    fill(r, g, b, 255 * a * iceProgress);
                    noStroke();
                    
                    // ê° ë¼ì¸ì˜ ë„ˆë¹„ë¥¼ ìœ„ìª½ ë² ì–´ë¬¸ì— ë”°ë¼ì„œë§Œ ì¡°ì •
                    let currentY = iceY + y;
                    let lineStartX = iceX;
                    let lineEndX = iceX + iceW;
                    
                    // ìœ„ìª½ ë² ì–´ë¬¸ íš¨ê³¼ë§Œ ì ìš© (y < iceH * 0.2 ì˜ì—­ì—ì„œë§Œ)
                    if (y < iceH * 0.45) { // ìƒìœ„ 15% ì˜ì—­ì—ì„œë§Œ ë² ì–´ë¬¸ ì ìš©
                        for (let bite of topBites) {
                            let biteX = iceX + bite.x;
                            let biteY = iceY + bite.y;
                            let distanceToBite = dist(0, currentY, 0, biteY);
                            
                            if (distanceToBite < bite.radius) {
                                let biteEffect = (bite.radius - distanceToBite) / bite.radius;
                                let cutDepth = bite.depth * bite.radius * biteEffect;
                                
                                // ë² ì–´ë¬¸ ìœ„ì¹˜ì— ë”°ë¼ ì¢Œìš°ì—ì„œ ì˜ë¼ëƒ„
                                if (bite.x < iceW * 0.3) {
                                    // ì™¼ìª½ì—ì„œ ë² ì–´ë¬¸
                                    lineStartX = Math.max(lineStartX, biteX + cutDepth);
                                } else if (bite.x > iceW * 0.7) {
                                    // ì˜¤ë¥¸ìª½ì—ì„œ ë² ì–´ë¬¸
                                    lineEndX = Math.min(lineEndX, biteX - cutDepth);
                                } else {
                                    // ê°€ìš´ë°ì—ì„œ ë² ì–´ë¬¸ (ìœ„ì•„ë˜ë¡œ)
                                    if (Math.abs(lineStartX + iceW/2 - biteX) < cutDepth) {
                                        // ì´ ì¤„ì€ ì™„ì „íˆ ë² ì–´ë¬¸ë¨
                                        lineStartX = lineEndX;
                                    }
                                }
                            }
                        }
                    }
                    
                    // ë² ì–´ë¬¸ì´ ì ìš©ëœ ë¼ì¸ ê·¸ë¦¬ê¸°
                    if (lineEndX > lineStartX) {
                        rect(lineStartX, currentY, lineEndX - lineStartX, 2);
                    }
                }
                
                // ì¶”ê°€ í…ìŠ¤ì²˜ íš¨ê³¼ (ë² ì–´ë¬¸ ë¶€ë¶„ ì œì™¸)
                if (progress > 0.5) {
                    let textureProgress = map(progress, 0.5, 0.8, 0, 1);
                    
                    for (let i = 0; i < 25 * textureProgress; i++) {
                        let tx = iceX + random(iceW);
                        let ty = iceY + random(iceH);
                        
                        // ìœ„ìª½ ë² ì–´ë¬¸ ë¶€ë¶„ì¸ì§€ í™•ì¸
                        let inBite = false;
                        if (ty - iceY < iceH * 0.15) { // ìƒìœ„ 15% ì˜ì—­ì—ì„œë§Œ ì²´í¬
                            for (let bite of topBites) {
                                let biteX = iceX + bite.x;
                                let biteY = iceY + bite.y;
                                if (dist(tx, ty, biteX, biteY) < bite.radius * bite.depth) {
                                    inBite = true;
                                    break;
                                }
                            }
                        }
                        
                        if (!inBite) {
                            let positionFactor = (ty - iceY) / iceH;
                            let textureAlpha = positionFactor * 0.15 * textureProgress;
                            
                            fill(255, 255, 255, textureAlpha * 255);
                            noStroke();
                            ellipse(tx, ty, random(0.2, 0.8), random(0.2, 0.8));
                        }
                    }
                }
            }
            
            // 3. ë…¸ë€ìƒ‰ ì ë“¤ - ìœ„ìª½ ë² ì–´ë¬¸ ë¶€ë¶„ ì œì™¸í•˜ê³  ê³ ë¥´ê²Œ ë°°ì¹˜
            if (progress > 0.6) {
                let dotProgress = map(progress, 0.6, 1, 0, 1);
                
                // ì•„ì´ìŠ¤í¬ë¦¼ ì˜ì—­ì— ë§ê²Œ ì ë“¤ ì¬ë°°ì¹˜
                let stickCenterX = offsetX + (541.74 + 33.23/2) * scale;
                let iceW = 200 * scale;
                let iceH = 350 * scale;
                let iceX = stickCenterX - iceW/2;
                let iceY = offsetY + 195 * scale;
                
                // ìƒˆë¡œìš´ ì ë“¤ ìœ„ì¹˜ (ìœ„ìª½ ë² ì–´ë¬¸ í”¼í•˜ê³  ê³ ë¥´ê²Œ ë¶„í¬)
                let dots = [
                    {x: 0.25, y: 0.3, r: 4},
                    {x: 0.75, y: 0.25, r: 3.0},
                    {x: 0.4, y: 0.4, r: 2.8},
                    {x: 0.6, y: 0.5, r: 3.2},
                    {x: 0.2, y: 0.6, r: 2.5},
                    {x: 0.8, y: 0.55, r: 2.7},
                    {x: 0.35, y: 0.7, r: 3.0},
                    {x: 0.65, y: 0.65, r: 5},
                    {x: 0.45, y: 0.8, r: 2.9},
                    {x: 0.55, y: 0.35, r: 5},
                    {x: 0.3, y: 0.85, r: 2.4},
                    {x: 0.7, y: 0.85, r: 5}
                ];
                
                for (let i = 0; i < dots.length; i++) {
                    let dot = dots[i];
                    
                    let individualProgress = map(progress, 0.6 + i * 0.015, 1, 0, 1);
                    individualProgress = constrain(individualProgress, 0, 1);
                    
                    if (individualProgress > 0) {
                        let dotX = iceX + dot.x * iceW;
                        let dotY = iceY + dot.y * iceH;
                        
                        // ìœ„ìª½ ë² ì–´ë¬¸ ë¶€ë¶„ì— ìˆëŠ”ì§€ í™•ì¸ (15% ì˜ì—­ì—ì„œë§Œ)
                        let inBite = false;
                        if (dot.y < 0.15) {
                            let topBites = [
                                {x: iceW * 0.15, y: iceH * 0.05, radius: 35 * scale},
                                {x: iceW * 0.85, y: iceH * 0.08, radius: 30 * scale},
                                {x: iceW * 0.45, y: iceH * 0.02, radius: 25 * scale}
                            ];
                            
                            for (let bite of topBites) {
                                let biteX = iceX + bite.x;
                                let biteY = iceY + bite.y;
                                if (dist(dotX, dotY, biteX, biteY) < bite.radius * 0.7) {
                                    inBite = true;
                                    break;
                                }
                            }
                        }
                        
                        if (!inBite) {
                            // ë¯¸ì„¸í•œ ë…¸ì´ì¦ˆ
                            let noiseX = noise(i * 10, frameCount * 0.008) * 1 - 0.5;
                            let noiseY = noise(i * 10 + 100, frameCount * 0.008) * 1 - 0.5;
                            
                            // ìƒ‰ìƒ ë³€í™” (ë” ì¼ê´€ëœ ë…¸ë€ìƒ‰)
                            let baseColor = [255, 255, 140]; // ë” ì§„í•œ ë…¸ë€ìƒ‰
                            let r = baseColor[0] + noise(i * 5, frameCount * 0.015) * 10 - 5;
                            let g = baseColor[1] + noise(i * 5 + 50, frameCount * 0.015) * 10 - 5;
                            let b = baseColor[2] + noise(i * 5 + 100, frameCount * 0.015) * 15 - 7.5;
                            
                            r = constrain(r, 240, 255);
                            g = constrain(g, 240, 255);
                            b = constrain(b, 120, 160);
                            
                            fill(r, g, b, 255 * 0.9 * individualProgress);
                            noStroke();
                            
                            let dotSize = dot.r * scale * individualProgress;
                            dotX += noiseX;
                            dotY += noiseY;
                            
                            ellipse(dotX, dotY, dotSize, dotSize);
                            
                            // í•˜ì´ë¼ì´íŠ¸
                            if (individualProgress > 0.5) {
                                fill(255, 255, 180, 80 * individualProgress);
                                ellipse(dotX - dotSize * 0.15, dotY - dotSize * 0.15, dotSize * 0.25, dotSize * 0.25);
                            }
                        }
                    }
                }
            }
            
            pop();
        }

        function drawPNGMorphing(crystalIndex, progress) {
    push();
    
    // PNG ì´ë¯¸ì§€ê°€ ë¡œë“œë˜ì—ˆëŠ”ì§€ í™•ì¸
    if (!pngImages[crystalIndex]) {
        // PNGê°€ ì—†ìœ¼ë©´ ì•„ì´ìŠ¤í¬ë¦¼ ìƒíƒœ ìœ ì§€
        if (crystalIndex === 0) {
            drawLemonIceCream(1.0);
        } else if (crystalIndex === 1) {
            drawStrawberryIceCream([100, 149, 237], 1.0);
        } else {
            drawBlueberryIceCream([100, 149, 237], 1.0);
        }
        pop();
        return;
    }
    
    // ë” ë¶€ë“œëŸ¬ìš´ ì´ì§• ì ìš©
    let morphEase = easeInOutSmoother(progress);
    
    // 1ë‹¨ê³„: ì•„ì´ìŠ¤í¬ë¦¼ê³¼ PNG ë¸”ë Œë”© (0-0.6) - ë” ê¸¸ê²Œ
    if (progress < 0.6) {
        let iceCreamAlpha = map(morphEase, 0, 0.6, 1.0, 0.1); // ì™„ì „íˆ ì‚¬ë¼ì§€ì§€ ì•Šê²Œ
        
        push();
        tint(255, 255 * iceCreamAlpha);
        if (crystalIndex === 0) {
            drawLemonIceCream(1.0);
        } else if (crystalIndex === 1) {
            drawStrawberryIceCream([100, 149, 237], 1.0);
        } else {
            drawBlueberryIceCream([100, 149, 237], 1.0);
        }
        noTint();
        pop();
    }
    
    // 2ë‹¨ê³„: PNG ì ì§„ì  ë“±ì¥ (0.3-1.0) - ê²¹ì¹˜ëŠ” êµ¬ê°„ ëŠ˜ë¦¼
    if (progress > 0.5) {
        let pngProgress = map(morphEase, 0.3, 1.0, 0, 1);
        
        // ë” ë¶€ë“œëŸ¬ìš´ ì•ŒíŒŒ ë³€í™”
        let pngAlpha = map(easeInOutCubic(pngProgress), 0, 1, 0, 255);
        
        // ìì—°ìŠ¤ëŸ¬ìš´ í¬ê¸° ë³€í™” (ì‘ê²Œ ì‹œì‘í•´ì„œ ì•½ê°„ ì»¤ì¡Œë‹¤ê°€ ì›ë˜ í¬ê¸°ë¡œ)
        let scalePhase1 = map(pngProgress, 0, 0.4, 0.3, 1.1); // ì‘ê²Œ ì‹œì‘í•´ì„œ ì•½ê°„ ì˜¤ë²„ì‚¬ì´ì¦ˆ
        let scalePhase2 = map(pngProgress, 0.4, 1.0, 1.1, 1.0); // ì›ë˜ í¬ê¸°ë¡œ ëŒì•„ì˜´
        let pngScale = pngProgress < 0.4 ? scalePhase1 : scalePhase2;
        
        // ë¯¸ì„¸í•œ íšŒì „ íš¨ê³¼
        let rotation = sin(pngProgress * PI) * 5; // ìµœëŒ€ 5ë„ íšŒì „
        
        // ì•½ê°„ì˜ ìœ„ì¹˜ ë³€í™” (ìì—°ìŠ¤ëŸ¬ìš´ "ì°©ì§€" íš¨ê³¼)
        let offsetY = map(easeOutBounce(pngProgress), 0, 1, -10, 0); // ìœ„ì—ì„œ ì•„ë˜ë¡œ ë–¨ì–´ì§€ë©° ì°©ì§€
        
        push();
        translate(0, offsetY);
        rotate(radians(rotation));
        
        tint(255, pngAlpha);
        imageMode(CENTER);
        
        // í¬ê¸° ê³„ì‚°
        // í¬ê¸° ê³„ì‚° - ê° í¬ë¦¬ìŠ¤íƒˆë³„ ê°œë³„ ì¡°ì •
let scaleMultipliers = [1.0, 1.0, 0.6]; // icy1, icy2, icy3 ìˆœì„œ
let baseScale = crystals[crystalIndex].scale * 0.05 * scaleMultipliers[crystalIndex];
let finalScale = baseScale * pngScale;
        
        image(pngImages[crystalIndex], 
              0, 0, 
              pngImages[crystalIndex].width * finalScale, 
              pngImages[crystalIndex].height * finalScale);
        
        noTint();
        pop();
    }
    
    
    
    pop();
}

// ëª¨í•‘ íŒŒí‹°í´ íš¨ê³¼ í•¨ìˆ˜ ì¶”ê°€
function drawMorphingParticles(crystalIndex, progress) {
    push();
    
    let particleCount = Math.floor(20 * progress);
    let crystalColor = crystals[crystalIndex].color;
    
    for (let i = 0; i < particleCount; i++) {
        let angle = (i / particleCount) * TWO_PI + frameCount * 0.02;
        let distance = 60 + sin(frameCount * 0.05 + i) * 20;
        let size = 2 + sin(frameCount * 0.1 + i * 0.5) * 1;
        
        let x = cos(angle) * distance * (1 - progress * 0.5);
        let y = sin(angle) * distance * (1 - progress * 0.5);
        
        let alpha = 150 * progress * (1 - i / particleCount);
        
        fill(crystalColor[0], crystalColor[1], crystalColor[2], alpha);
        noStroke();
        ellipse(x, y, size, size);
        
        // ë°˜ì§ì„ íš¨ê³¼
        if (random() < 0.3) {
            fill(255, 255, 255, alpha * 0.5);
            ellipse(x, y, size * 0.5, size * 0.5);
        }
    }
    
    pop();
}

        function drawStrawberryIceCream(color, progress) {
    push();
    
    // ìŠ¤ì¼€ì¼ ì¡°ì •
    let scale = 0.7;
    
    // progress = 0ì¼ ë•Œë„ ê¸°ë³¸ì ìœ¼ë¡œ ë³´ì´ë„ë¡ ìµœì†Œ íˆ¬ëª…ë„ ë³´ì¥
    let safeProgress = Math.max(0.3, progress);
    
    // SVG viewBox ê¸°ì¤€ìœ¼ë¡œ ì¢Œí‘œ ë³€í™˜ (107.97 x 140.73)
    // SVG ì´ë¯¸ì§€ì˜ ì‹¤ì œ í¬ê¸°ëŠ” 930x1207ì´ê³ , transformìœ¼ë¡œ 0.09 ìŠ¤ì¼€ì¼ ì ìš©ë¨
    translate(0, -20 * scale); // ì¤‘ì•™ ì •ë ¬ì„ ìœ„í•œ ì¡°ì •
    
    let cupProgress = safeProgress > 0.1 ? map(safeProgress, 0.1, 0.4, 0, 1) : 0.7;
    let scoopProgress = safeProgress > 0.3 ? map(safeProgress, 0.3, 0.8, 0, 1) : 0.6;
    
    // SVG ì´ë¯¸ì§€ë¥¼ base64ë¡œ ê·¸ëŒ€ë¡œ ë Œë”ë§í•˜ëŠ” ë°©ì‹ìœ¼ë¡œ ë³€ê²½
    // í•˜ì§€ë§Œ p5.jsì—ì„œëŠ” ì§ì ‘ SVGë¥¼ ë Œë”ë§í•˜ê¸° ì–´ë ¤ìš°ë¯€ë¡œ, 
    // SVGì˜ í˜•íƒœë¥¼ ë¶„ì„í•´ì„œ íŒ¨ìŠ¤ë¡œ ì¬êµ¬í˜„
    
    // 1. ì»µ ë¶€ë¶„ (SVGì˜ ì‚¬ë‹¤ë¦¬ê¼´ í˜•íƒœ ì°¸ê³ )
    fill(77, 255, 168, 255 * cupProgress); // SVGì˜ lightgreen ìƒ‰ìƒ
    noStroke();
    
    // SVG ì¢Œí‘œê³„ë¥¼ p5.js ì¢Œí‘œê³„ë¡œ ë³€í™˜
    beginShape();
    vertex(-55 * scale, 20 * scale);      
    vertex(55 * scale, 20 * scale);       
    vertex(35 * scale, 80 * scale);       
    vertex(-35 * scale, 80 * scale);      
    endShape(CLOSE);
    
    // 2. ì»µì˜ ìŠ¤íŠ¸ë¼ì´í”„ íŒ¨í„´
    push();
    drawingContext.save();
    
    // í´ë¦¬í•‘ ì˜ì—­ ì„¤ì •
    beginShape();
    vertex(-55 * scale, 20 * scale);
    vertex(55 * scale, 20 * scale);
    vertex(35 * scale, 80 * scale);
    vertex(-35 * scale, 80 * scale);
    endShape();
    drawingContext.clip();
    
    fill(100, 149, 237, 255 * cupProgress); // cornflower blue
    let stripeWidth = 5.75 * scale;
    let stripeSpacing = 14.7 * scale;
    
    for (let i = -8; i < 10; i++) {
        push();
        translate(i * stripeSpacing - 50 * scale, -50 * scale);
        rotate(radians(-17.5));
        rect(0, 0, stripeWidth, 300 * scale);
        pop();
    }
    
    drawingContext.restore();
    pop();
    
    // 3. ì²« ë²ˆì§¸ ì•„ì´ìŠ¤í¬ë¦¼ ìŠ¤ì¿± (cornflower blue)
    push();
    fill(100, 149, 237, 255 * scoopProgress);
    noStroke();
    
    beginShape();
    curveVertex(-55 * scale, 12 * scale);
    curveVertex(-58 * scale, 12 * scale);
    curveVertex(-52 * scale, -5 * scale);
    curveVertex(-30 * scale, -18 * scale);
    curveVertex(-42 * scale, -25 * scale);
    curveVertex(-38 * scale, -32 * scale);
    curveVertex(-32 * scale, -38 * scale);
    curveVertex(-25 * scale, -42 * scale);
    curveVertex(-18 * scale, -44 * scale);
    curveVertex(-10 * scale, -46 * scale);
    curveVertex(-2 * scale, -45 * scale);
    curveVertex(5 * scale, -42 * scale);
    curveVertex(10 * scale, -38 * scale);
    curveVertex(14 * scale, -32 * scale);
    curveVertex(17 * scale, -25 * scale);
    curveVertex(19 * scale, -18 * scale);
    curveVertex(22 * scale, -10 * scale);
    curveVertex(23 * scale, -2 * scale);
    curveVertex(22 * scale, 5 * scale);
    curveVertex(20 * scale, 12 * scale);
    curveVertex(16 * scale, 17 * scale);
    curveVertex(10 * scale, 20 * scale);
    curveVertex(2 * scale, 22 * scale);
    curveVertex(-8 * scale, 21 * scale);
    curveVertex(-18 * scale, 20 * scale);
    curveVertex(-28 * scale, 19 * scale);
    curveVertex(-38 * scale, 17 * scale);
    curveVertex(-45 * scale, 15 * scale);
    curveVertex(-55 * scale, 12 * scale);
    curveVertex(-55 * scale, 12 * scale);
    endShape();
    pop();
    
    // 4. ë‘ ë²ˆì§¸ ì•„ì´ìŠ¤í¬ë¦¼ ìŠ¤ì¿± (yellow)
    if (scoopProgress > 0.4 || safeProgress >= 0.3) {
        let yellowProgress = scoopProgress > 0.4 ? map(scoopProgress, 0.4, 1, 0, 1) : 0.5;
        
        push();
        drawingContext.globalCompositeOperation = 'multiply';
        fill(255, 255, 100, 200 * yellowProgress);
        noStroke();
        
        beginShape();
        curveVertex(-20 * scale, 10 * scale);
        curveVertex(-18 * scale, 5 * scale);
        curveVertex(-12 * scale, 1 * scale);
        curveVertex(-9 * scale, -5 * scale);
        curveVertex(-10 * scale, -7 * scale);
        curveVertex(-22 * scale, -15 * scale);
        curveVertex(-20 * scale, -25 * scale);
        curveVertex(-15 * scale, -32 * scale);
        curveVertex(-8 * scale, -35 * scale);
        curveVertex(0 * scale, -37 * scale);
        curveVertex(5 * scale, -36 * scale);
        curveVertex(8 * scale, -33 * scale);
        curveVertex(15 * scale, -35 * scale);
        curveVertex(25 * scale, -38 * scale);
        curveVertex(35 * scale, -37 * scale);
        curveVertex(42 * scale, -33 * scale);
        curveVertex(48 * scale, -25 * scale);
        curveVertex(52 * scale, -15 * scale);
        curveVertex(53 * scale, -5 * scale);
        curveVertex(50 * scale, 5 * scale);
        curveVertex(45 * scale, 10 * scale);
        curveVertex(48 * scale, 15 * scale);
        curveVertex(45 * scale, 20 * scale);
        curveVertex(40 * scale, 22 * scale);
        curveVertex(32 * scale, 23 * scale);
        curveVertex(22 * scale, 22 * scale);
        curveVertex(12 * scale, 20 * scale);
        curveVertex(2 * scale, 18 * scale);
        curveVertex(-8 * scale, 17 * scale);
        curveVertex(-15 * scale, 15 * scale);
        curveVertex(-15 * scale, 15 * scale);
        endShape();
        
        drawingContext.globalCompositeOperation = 'source-over';
        pop();
    }
    
    pop();
}

function drawPNGMorphing(crystalIndex, progress) {
    push();
    
   
    if (!pngImages[crystalIndex]) {
        
        if (crystalIndex === 0) {
            drawLemonIceCream(1.0);
        } else if (crystalIndex === 1) {
            drawStrawberryIceCream([100, 149, 237], 1.0);
        } else {
            drawBlueberryIceCream([100, 149, 237], 1.0);
        }
        pop();
        return;
    }
    
    
    let morphEase = easeInOutSmoother(progress);
    
    if (progress < 0.6) {
        let iceCreamAlpha = map(morphEase, 0, 0.6, 1.0, 0.1); 
        
        push();
        tint(255, 255 * iceCreamAlpha);
        if (crystalIndex === 0) {
            drawLemonIceCream(1.0);
        } else if (crystalIndex === 1) {
            drawStrawberryIceCream([100, 149, 237], 1.0);
        } else {
            drawBlueberryIceCream([100, 149, 237], 1.0);
        }
        noTint();
        pop();
    }
    
    // 2ë‹¨ê³„: PNG ì ì§„ì  ë“±ì¥ (0.3-1.0) - ê²¹ì¹˜ëŠ” êµ¬ê°„ ëŠ˜ë¦¼
    if (progress > 0.5) {
        let pngProgress = map(morphEase, 0.3, 1.0, 0, 1);
        
        // ë” ë¶€ë“œëŸ¬ìš´ ì•ŒíŒŒ ë³€í™”
        let pngAlpha = map(easeInOutCubic(pngProgress), 0, 1, 0, 255);
        
        // ìì—°ìŠ¤ëŸ¬ìš´ í¬ê¸° ë³€í™” (ì‘ê²Œ ì‹œì‘í•´ì„œ ì•½ê°„ ì»¤ì¡Œë‹¤ê°€ ì›ë˜ í¬ê¸°ë¡œ)
        let scalePhase1 = map(pngProgress, 0, 0.4, 0.3, 1.1); // ì‘ê²Œ ì‹œì‘í•´ì„œ ì•½ê°„ ì˜¤ë²„ì‚¬ì´ì¦ˆ
        let scalePhase2 = map(pngProgress, 0.4, 1.0, 1.1, 1.0); // ì›ë˜ í¬ê¸°ë¡œ ëŒì•„ì˜´
        let pngScale = pngProgress < 0.4 ? scalePhase1 : scalePhase2;
        
        // ë¯¸ì„¸í•œ íšŒì „ íš¨ê³¼
        let rotation = sin(pngProgress * PI) * 5; // ìµœëŒ€ 5ë„ íšŒì „
        
        // ì•½ê°„ì˜ ìœ„ì¹˜ ë³€í™” (ìì—°ìŠ¤ëŸ¬ìš´ "ì°©ì§€" íš¨ê³¼)
        let offsetY = map(easeOutBounce(pngProgress), 0, 1, -10, 0); // ìœ„ì—ì„œ ì•„ë˜ë¡œ ë–¨ì–´ì§€ë©° ì°©ì§€
        
        push();
        translate(0, offsetY);
        rotate(radians(rotation));
        
        tint(255, pngAlpha);
        imageMode(CENTER);
        
        // í¬ê¸° ê³„ì‚°
        // í¬ê¸° ê³„ì‚° - ê° í¬ë¦¬ìŠ¤íƒˆë³„ ê°œë³„ ì¡°ì •
let scaleMultipliers = [1.0, 1.0, 0.6]; // icy1, icy2, icy3 ìˆœì„œ
let baseScale = crystals[crystalIndex].scale * 0.05 * scaleMultipliers[crystalIndex];
let finalScale = baseScale * pngScale;
        
        image(pngImages[crystalIndex], 
              0, 0, 
              pngImages[crystalIndex].width * finalScale, 
              pngImages[crystalIndex].height * finalScale);
        
        noTint();
        pop();
    }
    
    
    
    pop();
}

// ëª¨í•‘ íŒŒí‹°í´ íš¨ê³¼ í•¨ìˆ˜ ì¶”ê°€
function drawMorphingParticles(crystalIndex, progress) {
    push();
    
    let particleCount = Math.floor(20 * progress);
    let crystalColor = crystals[crystalIndex].color;
    
    for (let i = 0; i < particleCount; i++) {
        let angle = (i / particleCount) * TWO_PI + frameCount * 0.02;
        let distance = 60 + sin(frameCount * 0.05 + i) * 20;
        let size = 2 + sin(frameCount * 0.1 + i * 0.5) * 1;
        
        let x = cos(angle) * distance * (1 - progress * 0.5);
        let y = sin(angle) * distance * (1 - progress * 0.5);
        
        let alpha = 150 * progress * (1 - i / particleCount);
        
        fill(crystalColor[0], crystalColor[1], crystalColor[2], alpha);
        noStroke();
        ellipse(x, y, size, size);
        
        // ë°˜ì§ì„ íš¨ê³¼
        if (random() < 0.3) {
            fill(255, 255, 255, alpha * 0.5);
            ellipse(x, y, size * 0.5, size * 0.5);
        }
    }
    
    pop();
}

        function drawBlueberryIceCream(color, progress) {
    push();
    
    // ì „ì²´ ìŠ¤ì¼€ì¼ ì¡°ì •
    let scale = 0.8;
    
    // progressê°€ 0.8ì„ ë„˜ìœ¼ë©´ SVG ìŠ¤íƒ€ì¼ë¡œ ëª¨í•‘ ì‹œì‘
    if (progress > 0.8) {
        let morphProgress = map(progress, 0.8, 1.0, 0, 1);
        morphProgress = easeInOutSmoother(morphProgress); // ë¶€ë“œëŸ¬ìš´ ì „í™˜
        
        // ê¸°ì¡´ ì•„ì´ìŠ¤í¬ë¦¼ ê·¸ë˜í”½ì˜ íˆ¬ëª…ë„ ê°ì†Œ
        let oldAlpha = 255 * (1 - morphProgress);
        
        // SVG ìŠ¤íƒ€ì¼ì˜ íˆ¬ëª…ë„ ì¦ê°€
        let newAlpha = 255 * morphProgress;
        
        // ê¸°ì¡´ ì•„ì´ìŠ¤í¬ë¦¼ ê·¸ë˜í”½ ê·¸ë¦¬ê¸° (íˆ¬ëª…ë„ ì ìš©)
        drawOriginalIceCream(scale, oldAlpha, progress);
        
        // SVG ì•„ì´ìŠ¤í¬ë¦¼ ê·¸ë¦¬ê¸°
        drawSVGIceCream(scale, newAlpha); 
        
    } else {
        // progressê°€ 0.8 ì´í•˜ì¼ ë•ŒëŠ” ê¸°ì¡´ ì•„ì´ìŠ¤í¬ë¦¼ë§Œ ê·¸ë¦¬ê¸°
        drawOriginalIceCream(scale, 255, progress);
    }
    
    pop();
}

// SVG ì•„ì´ìŠ¤í¬ë¦¼ì„ ê·¸ë¦¬ëŠ” í•¨ìˆ˜
function drawSVGIceCream(scale, alpha) {
    push();
    
    // SVG ì¢Œí‘œë¥¼ p5.js ì¢Œí‘œë¡œ ë³€í™˜í•˜ëŠ” í•¨ìˆ˜
    function svgX(x) { return (x - 52.92) * scale * 0.8; }
    function svgY(y) { return (y - 67.425) * scale * 0.8; }
    
    // 1. ì½˜ (cls-4, #f2ffa8) - ë” ê¸¸ê²Œ
    fill(242, 255, 168, alpha);
    noStroke();
    beginShape();
    vertex(svgX(36.13), svgY(61.78));
    vertex(svgX(72.34), svgY(61.78));
    vertex(svgX(54.24), svgY(135)); // ë” ê¸¸ê²Œ í™•ì¥
    endShape(CLOSE);
    
    // ê³µí†µ ìŠ¤ì¿± í˜•íƒœ ì •ì˜ (ë” ì‘ê²Œ)
    let scoopShape = [
        {angle: 0, radius: 16}, {angle: 0.6, radius: 18}, {angle: 1.2, radius: 20},
        {angle: 1.8, radius: 21}, {angle: 2.4, radius: 19}, {angle: 3.0, radius: 17},
        {angle: 3.6, radius: 16}, {angle: 4.2, radius: 19}, {angle: 4.8, radius: 21},
        {angle: 5.4, radius: 19}, {angle: 6.0, radius: 16}
    ];
    
    // 2. ë…¹ìƒ‰ ìŠ¤ì¿± (ì™¼ìª½)
    fill(0, 255, 121, alpha);
    noStroke();
    drawSmoothBlob(42, 35, 15, 21, scoopShape, scale, alpha);
    
    // 3. íŒŒë€ìƒ‰ ìŠ¤ì¿± (ì˜¤ë¥¸ìª½)
    fill(101, 169, 253, alpha * 0.8);
    noStroke();
    drawSmoothBlob(64, 35, 15, 21, scoopShape, scale, alpha * 0.8);
    
    // 4. ë…¸ë€ìƒ‰ ìŠ¤ì¿± (ìœ„ìª½ ì¤‘ì•™)
    fill(251, 242, 54, alpha * 0.5);
    noStroke();
    drawSmoothBlob(53, 20, 15, 21, scoopShape, scale, alpha * 0.5);
    
    // 5. ì½˜ì˜ íŒŒë€ìƒ‰ ì¥ì‹ë“¤ (cls-5, #5ea6fd)
    fill(94, 166, 253, alpha);
    noStroke();
    
    // ì²« ë²ˆì§¸ íŒŒë€ìƒ‰ ì¥ì‹
    beginShape();
    vertex(svgX(48.13), svgY(101.66));
    vertex(svgX(57.16), svgY(112.21));
    vertex(svgX(47.36), svgY(99.07));
    endShape(CLOSE);
    
    // ë‘ ë²ˆì§¸ íŒŒë€ìƒ‰ ì¥ì‹
    beginShape();
    vertex(svgX(45.4), svgY(92.57));
    vertex(svgX(58.31), svgY(108.39));
    vertex(svgX(44.21), svgY(88.64));
    endShape(CLOSE);
    
    pop();
}

// ë¶€ë“œëŸ¬ìš´ blob í˜•íƒœë¥¼ ê·¸ë¦¬ëŠ” í•¨ìˆ˜
function drawSmoothBlob(centerX, centerY, minRadius, maxRadius, points, scale, alpha) {
    push();
    
    // SVG ì¢Œí‘œë¥¼ p5.js ì¢Œí‘œë¡œ ë³€í™˜
    let x = (centerX - 52.92) * scale * 0.8;
    let y = (centerY - 67.425) * scale * 0.8;
    
    translate(x, y);
    
    beginShape();
    
    // ë² ì§€ì–´ ê³¡ì„ ì„ ì‚¬ìš©í•˜ì—¬ ë¶€ë“œëŸ¬ìš´ í˜•íƒœ ìƒì„±
    let numPoints = points.length;
    
    for (let i = 0; i < numPoints; i++) {
        let current = points[i];
        let next = points[(i + 1) % numPoints];
        
        // í˜„ì¬ ì ì˜ ì¢Œí‘œ ê³„ì‚°
        let currentR = map(current.radius, 0, 50, minRadius, maxRadius) * scale;
        let currentX = cos(current.angle) * currentR;
        let currentY = sin(current.angle) * currentR;
        
        // ë‹¤ìŒ ì ì˜ ì¢Œí‘œ ê³„ì‚°
        let nextR = map(next.radius, 0, 50, minRadius, maxRadius) * scale;
        let nextX = cos(next.angle) * nextR;
        let nextY = sin(next.angle) * nextR;
        
        if (i === 0) {
            vertex(currentX, currentY);
        }
        
        // ë² ì§€ì–´ ê³¡ì„ ì˜ ì œì–´ì  ê³„ì‚°
        let controlDist1 = currentR * 0.3;
        let controlDist2 = nextR * 0.3;
        
        let control1X = currentX + cos(current.angle + PI/2) * controlDist1;
        let control1Y = currentY + sin(current.angle + PI/2) * controlDist1;
        
        let control2X = nextX + cos(next.angle - PI/2) * controlDist2;
        let control2Y = nextY + sin(next.angle - PI/2) * controlDist2;
        
        // ë² ì§€ì–´ ê³¡ì„ ìœ¼ë¡œ ì—°ê²°
        bezierVertex(control1X, control1Y, control2X, control2Y, nextX, nextY);
    }
    
    endShape(CLOSE);
    pop();
}

// ê¸°ì¡´ ì•„ì´ìŠ¤í¬ë¦¼ ê·¸ë˜í”½ì„ ë³„ë„ í•¨ìˆ˜ë¡œ ë¶„ë¦¬
function drawOriginalIceCream(scale, alpha, progress) {
    // 1. ë…¸ë€ìƒ‰ ì´ë“±ë³€ì‚¼ê°í˜• ì½˜ (ìœ„ë¥¼ í–¥í•¨ - 180ë„ ë’¤ì§‘íŒ í˜•íƒœ)
    if (progress > 0.1) {
        let coneProgress = map(progress, 0.1, 0.4, 0, 1);
        
        fill(255, 255, 160, alpha * coneProgress); // ì—°í•œ ë…¸ë€ìƒ‰
        noStroke();
        
        // ìœ„ë¥¼ í–¥í•œ ì´ë“±ë³€ì‚¼ê°í˜• ì½˜
        beginShape();
        vertex(0, 60 * scale);          // ìƒë‹¨ ê¼­ì§“ì 
        vertex(-25 * scale, -20 * scale); // ì™¼ìª½ í•˜ë‹¨
        vertex(25 * scale, -20 * scale);  // ì˜¤ë¥¸ìª½ í•˜ë‹¨
        endShape(CLOSE);
    }

    // 2. RGB ë²¤ë‹¤ì´ì–´ê·¸ë¨ ìŠ¤íƒ€ì¼ì˜ 3ê°œ ìŠ¤ì¿± (ì½˜ ìœ„ì— ë°°ì¹˜)
    let scoopRadius = 22 * scale; // ìŠ¤ì¿± í¬ê¸°ë¥¼ ë” ì‘ê²Œ
    let scoopY = -40 * scale; // ì½˜ ìœ„ì— ìœ„ì¹˜
    
    // ì™¼ìª½ ìŠ¤ì¿± (Forest Green)
    if (progress > 0.3) {
        let leftProgress = map(progress, 0.3, 0.6, 0, 1);
        
        push();
        translate(-15 * scale, scoopY);
        
        fill(77, 255, 168, alpha * leftProgress); // Forest Green
        noStroke();
        
        // ì˜¤ê¸€ì˜¤ê¸€í•œ ì›í˜•
        beginShape();
        for (let angle = 0; angle < TWO_PI; angle += 0.3) {
            let noiseValue = noise(cos(angle) * 0.8, sin(angle) * 0.8, frameCount * 0.01);
            let r = scoopRadius + (noiseValue - 0.5) * 8 * scale;
            let x = cos(angle) * r;
            let y = sin(angle) * r;
            vertex(x, y);
        }
        endShape(CLOSE);
        pop();
    }
    
    // ì˜¤ë¥¸ìª½ ìŠ¤ì¿± (Cornflower Blue)
    if (progress > 0.5) {
        let rightProgress = map(progress, 0.5, 0.75, 0, 1);
        
        push();
        translate(15 * scale, scoopY);
        
        fill(100, 149, 237, alpha * rightProgress); // Cornflower Blue
        noStroke();
        
        // ì˜¤ê¸€ì˜¤ê¸€í•œ ì›í˜•
        beginShape();
        for (let angle = 0; angle < TWO_PI; angle += 0.5) {
            let noiseValue = noise(cos(angle) * 1.2 + 10, sin(angle) * 1.2 + 10, frameCount * 0.01);
            let r = scoopRadius + (noiseValue - 0.8) * 8 * scale;
            let x = cos(angle) * r;
            let y = sin(angle) * r;
            vertex(x, y);
        }
        endShape(CLOSE);
        pop();
    }
    
    // ê°€ìš´ë° ìœ„ìª½ ìŠ¤ì¿± (Yellow)
    if (progress > 0.7) {
        let topProgress = map(progress, 0.7, 1, 0, 1);
        
        push();
        translate(0, scoopY - 10 * scale); // ì‚´ì§ ìœ„ìª½ì— ìœ„ì¹˜
        
        fill(255, 255, 0, alpha * topProgress); // ìˆœìˆ˜í•œ ë…¸ë€ìƒ‰
        noStroke();
        
        // ì˜¤ê¸€ì˜¤ê¸€í•œ ì›í˜•
        beginShape();
        for (let angle = 0; angle < TWO_PI; angle += 0.3) {
            let noiseValue = noise(cos(angle) * 0.6 + 20, sin(angle) * 0.6 + 20, frameCount * 0.01);
            let r = scoopRadius + (noiseValue - 0.5) * 8 * scale;
            let x = cos(angle) * r;
            let y = sin(angle) * r;
            vertex(x, y);
        }
        endShape(CLOSE);
        pop();
    }
}       // Easing í•¨ìˆ˜ë“¤
        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - pow(-2 * t + 2, 3) / 2;
        }
        
        function easeInOutQuart(t) {
            return t < 0.5 ? 8 * t * t * t * t : 1 - pow(-2 * t + 2, 4) / 2;
        }
        
        function easeInOutBounce(t) {
            return t < 0.5 
                ? (1 - easeOutBounce(1 - 2 * t)) / 2
                : (1 + easeOutBounce(2 * t - 1)) / 2;
        }
        
        function easeOutBounce(t) {
            if (t < 1 / 2.75) {
                return 7.5625 * t * t;
            } else if (t < 2 / 2.75) {
                return 7.5625 * (t -= 1.5 / 2.75) * t + 0.75;
            } else if (t < 2.5 / 2.75) {
                return 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375;
            } else {
                return 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;
            }
        }

        // ë” ë¶€ë“œëŸ¬ìš´ easing í•¨ìˆ˜ ì¶”ê°€
function easeInOutSmooth(t) {
    return t * t * (3.0 - 2.0 * t); // ë” ë¶€ë“œëŸ¬ìš´ ê³¡ì„ 
}

function easeInOutSmoother(t) {
    return t * t * t * (t * (t * 6 - 15) + 10); // ë§¤ìš° ë¶€ë“œëŸ¬ìš´ ê³¡ì„ 
}

function drawPNGMorphing(crystalIndex, progress) {
    push();
    
    // PNG ì´ë¯¸ì§€ê°€ ë¡œë“œë˜ì—ˆëŠ”ì§€ í™•ì¸
    if (!pngImages[crystalIndex]) {
        // PNGê°€ ì—†ìœ¼ë©´ ì•„ì´ìŠ¤í¬ë¦¼ ìƒíƒœ ìœ ì§€
        if (crystalIndex === 0) {
            drawLemonIceCream(1.0);
        } else if (crystalIndex === 1) {
            drawStrawberryIceCream([100, 149, 237], 1.0);
        } else {
            drawBlueberryIceCream([100, 149, 237], 1.0);
        }
        pop();
        return;
    }
    
    // ë” ë¶€ë“œëŸ¬ìš´ ì´ì§• ì ìš©
    let morphEase = easeInOutSmoother(progress);
    
    // 1ë‹¨ê³„: ì•„ì´ìŠ¤í¬ë¦¼ê³¼ PNG ë¸”ë Œë”© (0-0.6) - ë” ê¸¸ê²Œ
    if (progress < 0.6) {
        let iceCreamAlpha = map(morphEase, 0, 0.6, 1.0, 0.1); // ì™„ì „íˆ ì‚¬ë¼ì§€ì§€ ì•Šê²Œ
        
        push();
        tint(255, 255 * iceCreamAlpha);
        if (crystalIndex === 0) {
            drawLemonIceCream(1.0);
        } else if (crystalIndex === 1) {
            drawStrawberryIceCream([100, 149, 237], 1.0);
        } else {
            drawBlueberryIceCream([100, 149, 237], 1.0);
        }
        noTint();
        pop();
    }
    
    // 2ë‹¨ê³„: PNG ì ì§„ì  ë“±ì¥ (0.3-1.0) - ê²¹ì¹˜ëŠ” êµ¬ê°„ ëŠ˜ë¦¼
    if (progress > 0.5) {
        let pngProgress = map(morphEase, 0.3, 1.0, 0, 1);
        
        // ë” ë¶€ë“œëŸ¬ìš´ ì•ŒíŒŒ ë³€í™”
        let pngAlpha = map(easeInOutCubic(pngProgress), 0, 1, 0, 255);
        
        // ìì—°ìŠ¤ëŸ¬ìš´ í¬ê¸° ë³€í™” (ì‘ê²Œ ì‹œì‘í•´ì„œ ì•½ê°„ ì»¤ì¡Œë‹¤ê°€ ì›ë˜ í¬ê¸°ë¡œ)
        let scalePhase1 = map(pngProgress, 0, 0.4, 0.3, 1.1); // ì‘ê²Œ ì‹œì‘í•´ì„œ ì•½ê°„ ì˜¤ë²„ì‚¬ì´ì¦ˆ
        let scalePhase2 = map(pngProgress, 0.4, 1.0, 1.1, 1.0); // ì›ë˜ í¬ê¸°ë¡œ ëŒì•„ì˜´
        let pngScale = pngProgress < 0.4 ? scalePhase1 : scalePhase2;
        
        // ë¯¸ì„¸í•œ íšŒì „ íš¨ê³¼
        let rotation = sin(pngProgress * PI) * 5; // ìµœëŒ€ 5ë„ íšŒì „
        
        // ì•½ê°„ì˜ ìœ„ì¹˜ ë³€í™” (ìì—°ìŠ¤ëŸ¬ìš´ "ì°©ì§€" íš¨ê³¼)
        let offsetY = map(easeOutBounce(pngProgress), 0, 1, -10, 0); // ìœ„ì—ì„œ ì•„ë˜ë¡œ ë–¨ì–´ì§€ë©° ì°©ì§€
        
        push();
        translate(0, offsetY);
        rotate(radians(rotation));
        
        tint(255, pngAlpha);
        imageMode(CENTER);
        
        // í¬ê¸° ê³„ì‚°
        // í¬ê¸° ê³„ì‚° - ê° í¬ë¦¬ìŠ¤íƒˆë³„ ê°œë³„ ì¡°ì •
let scaleMultipliers = [1.0, 1.0, 0.6]; // icy1, icy2, icy3 ìˆœì„œ
let baseScale = crystals[crystalIndex].scale * 0.05 * scaleMultipliers[crystalIndex];
let finalScale = baseScale * pngScale;
        
        image(pngImages[crystalIndex], 
              0, 0, 
              pngImages[crystalIndex].width * finalScale, 
              pngImages[crystalIndex].height * finalScale);
        
        noTint();
        pop();
    }
    
    
    
    pop();
}

// ìŠ¤í¬ë¡¤ í…ìŠ¤íŠ¸ ê·¸ë¦¬ê¸° í•¨ìˆ˜
function drawScrollText() {
    push();
    
    // ì½”ë”© í°íŠ¸ ìŠ¤íƒ€ì¼ ì„¤ì •
    textAlign(CENTER, CENTER);
    let fontSize = canvasWidth * 0.08; // ë°˜ì‘í˜• í¬ê¸°
    textSize(fontSize);
    
    // í…ìŠ¤íŠ¸ ìœ„ì¹˜
    let textX = canvasWidth / 2;
    let textY = canvasHeight * 0.12; // ìƒë‹¨ì— ìœ„ì¹˜
    
    // cornflower blue ìƒ‰ìƒìœ¼ë¡œ í…ìŠ¤íŠ¸ ê·¸ë¦¬ê¸°
    fill(100, 149, 237, 255);
    text("SCROLL INTO SWEETNESS", textX, textY);
    
    pop();
}

// ëª¨í•‘ íŒŒí‹°í´ íš¨ê³¼ í•¨ìˆ˜ ì¶”ê°€
function drawMorphingParticles(crystalIndex, progress) {
    push();
    
    let particleCount = Math.floor(20 * progress);
    let crystalColor = crystals[crystalIndex].color;
    
    for (let i = 0; i < particleCount; i++) {
        let angle = (i / particleCount) * TWO_PI + frameCount * 0.02;
        let distance = 60 + sin(frameCount * 0.05 + i) * 20;
        let size = 2 + sin(frameCount * 0.1 + i * 0.5) * 1;
        
        let x = cos(angle) * distance * (1 - progress * 0.5);
        let y = sin(angle) * distance * (1 - progress * 0.5);
        
        let alpha = 150 * progress * (1 - i / particleCount);
        
        fill(crystalColor[0], crystalColor[1], crystalColor[2], alpha);
        noStroke();
        ellipse(x, y, size, size);
        
        // ë°˜ì§ì„ íš¨ê³¼
        if (random() < 0.3) {
            fill(255, 255, 255, alpha * 0.5);
            ellipse(x, y, size * 0.5, size * 0.5);
        }
    }
    
    pop();
}
        // í—¬í¼ í•¨ìˆ˜ë“¤
        function svgToP5X(svgX, centerX, scale) {
            return (svgX - centerX) * scale;
        }
        
        function svgToP5Y(svgY, centerY, scale) {
            return (svgY - centerY) * scale;
        }

        function drawSVGRoundedRect(x, y, w, h, rx, centerX, centerY, scale) {
            let px = svgToP5X(x, centerX, scale);
            let py = svgToP5Y(y, centerY, scale);
            rect(px, py, w * scale, h * scale, rx * scale);
        }

        function drawSVGPath1(points, centerX, centerY, scale) {
            beginShape();
            for (let point of points) {
                let px = svgToP5X(point[0], centerX, scale);
                let py = svgToP5Y(point[1], centerY, scale);
                vertex(px, py);
            }
            endShape(CLOSE);
        }

        function drawSVGPolygon(points, centerX, centerY, scale) {
            beginShape();
            for (let point of points) {
                let px = svgToP5X(point[0], centerX, scale);
                let py = svgToP5Y(point[1], centerY, scale);
                vertex(px, py);
            }
            endShape(CLOSE);
        }

        // ì´ë²¤íŠ¸ ì²˜ë¦¬ í•¨ìˆ˜ë“¤
        function mouseMoved() {
            activeCrystal = -1;
            for (let i = 0; i < crystals.length; i++) {
                let d = dist(mouseX, mouseY, crystals[i].x, crystals[i].y);
                if (d < crystals[i].scale * 120) {
                    activeCrystal = i;
                    break;
                }
            }
        }

        function mouseWheel(event) {
            if (activeCrystal >= 0) {
                let delta = event.delta;
                let sensitivity = 0.003;
                
                crystalProgress[activeCrystal] += delta * sensitivity;
                crystalProgress[activeCrystal] = constrain(crystalProgress[activeCrystal], 0, 1);
                
                return false;
            }
        }

        function keyPressed() {
            if (activeCrystal >= 0) {
                let delta = 0;
                switch(key) {
                    case 'ArrowUp':
                    case 'ArrowLeft':
                        delta = -0.04;
                        break;
                    case 'ArrowDown':
                    case 'ArrowRight':
                        delta = 0.04;
                        break;
                    case ' ':
                        delta = 0.08;
                        break;
                    case 'r':
                    case 'R':
                        crystalProgress[activeCrystal] = 0;
                        return;
                }
                
                if (delta !== 0) {
                    crystalProgress[activeCrystal] += delta;
                    crystalProgress[activeCrystal] = constrain(crystalProgress[activeCrystal], 0, 1);
                }
            }
            
            if (key >= '1' && key <= '3') {
                activeCrystal = parseInt(key) - 1;
            }
        }

        function doubleClicked() {
            for (let i = 0; i < crystals.length; i++) {
                let d = dist(mouseX, mouseY, crystals[i].x, crystals[i].y);
                if (d < crystals[i].scale * 120) {
                    crystalProgress[i] = 0;
                    break;
                }
            }
        }

        // í„°ì¹˜ ì§€ì›
        let touchStartY = 0;
        let touchCrystal = -1;

        function touchStarted() {
            if (touches.length > 0) {
                touchStartY = touches[0].y;
                for (let i = 0; i < crystals.length; i++) {
                    let d = dist(touches[0].x, touches[0].y, crystals[i].x, crystals[i].y);
                    if (d < crystals[i].scale * 120) {
                        touchCrystal = i;
                        activeCrystal = i;
                        break;
                    }
                }
            }
            return false;
        }

        function touchMoved() {
            if (touchCrystal >= 0 && touches.length > 0) {
                let deltaY = touchStartY - touches[0].y;
                let sensitivity = 0.01;
                
                crystalProgress[touchCrystal] += deltaY * sensitivity;
                crystalProgress[touchCrystal] = constrain(crystalProgress[touchCrystal], 0, 1);
                
                touchStartY = touches[0].y;
            }
            return false;
        }

        function touchEnded() {
            touchCrystal = -1;
            activeCrystal = -1;
            return false;
        }

        // ìœˆë„ìš° ë¦¬ì‚¬ì´ì¦ˆ ì²˜ë¦¬
        function windowResized() {
            let windowRatio = windowWidth / windowHeight;
            let a3Ratio = 1.414;
            
            if (windowRatio > a3Ratio) {
                canvasHeight = windowHeight;
                canvasWidth = canvasHeight * a3Ratio;
            } else {
                canvasWidth = windowWidth;
                canvasHeight = canvasWidth / a3Ratio;
            }
            
            resizeCanvas(canvasWidth, canvasHeight);
            
            let spacing = canvasWidth / 3;
            let graphicScale = Math.min(canvasWidth / 1200, canvasHeight / 600) * 3.5;
            
            for (let i = 0; i < crystals.length; i++) {
                crystals[i].x = spacing * (i + 0.5);
                crystals[i].y = canvasHeight * 0.5;
                crystals[i].scale = graphicScale;
            }
        }
    </script>
</body>
</html>